import{b as v}from"./buffer-Ce5O-hDk.js";import{s as wt,a as it,e as je}from"./@noble-CqNZeO14.js";import{B as at}from"./bn.js-BUi-eOe1.js";import{b as z}from"./bs58-D21jO5-q.js";import{s as sn,d as rn,a as on}from"./borsh-CS5d1WFI.js";import{t as an,a as cn}from"./bigint-buffer-BNJRNhsg.js";import{c as Ee,t as Ve,s as h,l as O,a as m,n as y,b as d,d as u,o as A,u as j,e as te,i as $e,f as ye,g as un,h as f,r as St}from"./superstruct-ChmvbrAv.js";import{R as ln}from"./jayson-B0kYyBvL.js";import{C as dn,W as hn}from"./rpc-websockets-DFyPd71n.js";var l={};Object.defineProperty(l,"__esModule",{value:!0});l.s16=l.s8=l.nu64be=l.u48be=l.u40be=l.u32be=l.u24be=l.u16be=W=l.nu64=l.u48=l.u40=_=l.u32=l.u24=J=l.u16=N=l.u8=ae=l.offset=l.greedy=l.Constant=l.UTF8=l.CString=l.Blob=l.Boolean=l.BitField=l.BitStructure=l.VariantLayout=l.Union=l.UnionLayoutDiscriminator=l.UnionDiscriminator=l.Structure=l.Sequence=l.DoubleBE=l.Double=l.FloatBE=l.Float=l.NearInt64BE=l.NearInt64=l.NearUInt64BE=l.NearUInt64=l.IntBE=l.Int=l.UIntBE=l.UInt=l.OffsetLayout=l.GreedyCount=l.ExternalLayout=l.bindConstructorLayout=l.nameWithProperty=l.Layout=l.uint8ArrayToBuffer=l.checkUint8Array=void 0;l.constant=l.utf8=l.cstr=F=l.blob=l.unionLayoutDiscriminator=l.union=G=l.seq=l.bits=w=l.struct=l.f64be=l.f64=l.f32be=l.f32=l.ns64be=l.s48be=l.s40be=l.s32be=l.s24be=l.s16be=$=l.ns64=l.s48=l.s40=l.s32=l.s24=void 0;const Je=v;function be(i){if(!(i instanceof Uint8Array))throw new TypeError("b must be a Uint8Array")}l.checkUint8Array=be;function P(i){return be(i),Je.Buffer.from(i.buffer,i.byteOffset,i.length)}l.uint8ArrayToBuffer=P;class U{constructor(e,t){if(!Number.isInteger(e))throw new TypeError("span must be an integer");this.span=e,this.property=t}makeDestinationObject(){return{}}getSpan(e,t){if(0>this.span)throw new RangeError("indeterminate span");return this.span}replicate(e){const t=Object.create(this.constructor.prototype);return Object.assign(t,this),t.property=e,t}fromArray(e){}}l.Layout=U;function Xe(i,e){return e.property?i+"["+e.property+"]":i}l.nameWithProperty=Xe;function fn(i,e){if(typeof i!="function")throw new TypeError("Class must be constructor");if(Object.prototype.hasOwnProperty.call(i,"layout_"))throw new Error("Class is already bound to a layout");if(!(e&&e instanceof U))throw new TypeError("layout must be a Layout");if(Object.prototype.hasOwnProperty.call(e,"boundConstructor_"))throw new Error("layout is already bound to a constructor");i.layout_=e,e.boundConstructor_=i,e.makeDestinationObject=()=>new i,Object.defineProperty(i.prototype,"encode",{value(t,n){return e.encode(this,t,n)},writable:!0}),Object.defineProperty(i,"decode",{value(t,n){return e.decode(t,n)},writable:!0})}l.bindConstructorLayout=fn;class V extends U{isCount(){throw new Error("ExternalLayout is abstract")}}l.ExternalLayout=V;class kt extends V{constructor(e=1,t){if(!Number.isInteger(e)||0>=e)throw new TypeError("elementSpan must be a (positive) integer");super(-1,t),this.elementSpan=e}isCount(){return!0}decode(e,t=0){be(e);const n=e.length-t;return Math.floor(n/this.elementSpan)}encode(e,t,n){return 0}}l.GreedyCount=kt;class Ze extends V{constructor(e,t=0,n){if(!(e instanceof U))throw new TypeError("layout must be a Layout");if(!Number.isInteger(t))throw new TypeError("offset must be integer or undefined");super(e.span,n||e.property),this.layout=e,this.offset=t}isCount(){return this.layout instanceof Q||this.layout instanceof ee}decode(e,t=0){return this.layout.decode(e,t+this.offset)}encode(e,t,n=0){return this.layout.encode(e,t,n+this.offset)}}l.OffsetLayout=Ze;class Q extends U{constructor(e,t){if(super(e,t),6<this.span)throw new RangeError("span must not exceed 6 bytes")}decode(e,t=0){return P(e).readUIntLE(t,this.span)}encode(e,t,n=0){return P(t).writeUIntLE(e,n,this.span),this.span}}l.UInt=Q;class ee extends U{constructor(e,t){if(super(e,t),6<this.span)throw new RangeError("span must not exceed 6 bytes")}decode(e,t=0){return P(e).readUIntBE(t,this.span)}encode(e,t,n=0){return P(t).writeUIntBE(e,n,this.span),this.span}}l.UIntBE=ee;class ce extends U{constructor(e,t){if(super(e,t),6<this.span)throw new RangeError("span must not exceed 6 bytes")}decode(e,t=0){return P(e).readIntLE(t,this.span)}encode(e,t,n=0){return P(t).writeIntLE(e,n,this.span),this.span}}l.Int=ce;class we extends U{constructor(e,t){if(super(e,t),6<this.span)throw new RangeError("span must not exceed 6 bytes")}decode(e,t=0){return P(e).readIntBE(t,this.span)}encode(e,t,n=0){return P(t).writeIntBE(e,n,this.span),this.span}}l.IntBE=we;const We=Math.pow(2,32);function Pe(i){const e=Math.floor(i/We),t=i-e*We;return{hi32:e,lo32:t}}function Ne(i,e){return i*We+e}class It extends U{constructor(e){super(8,e)}decode(e,t=0){const n=P(e),s=n.readUInt32LE(t),r=n.readUInt32LE(t+4);return Ne(r,s)}encode(e,t,n=0){const s=Pe(e),r=P(t);return r.writeUInt32LE(s.lo32,n),r.writeUInt32LE(s.hi32,n+4),8}}l.NearUInt64=It;class _t extends U{constructor(e){super(8,e)}decode(e,t=0){const n=P(e),s=n.readUInt32BE(t),r=n.readUInt32BE(t+4);return Ne(s,r)}encode(e,t,n=0){const s=Pe(e),r=P(t);return r.writeUInt32BE(s.hi32,n),r.writeUInt32BE(s.lo32,n+4),8}}l.NearUInt64BE=_t;class At extends U{constructor(e){super(8,e)}decode(e,t=0){const n=P(e),s=n.readUInt32LE(t),r=n.readInt32LE(t+4);return Ne(r,s)}encode(e,t,n=0){const s=Pe(e),r=P(t);return r.writeUInt32LE(s.lo32,n),r.writeInt32LE(s.hi32,n+4),8}}l.NearInt64=At;class Rt extends U{constructor(e){super(8,e)}decode(e,t=0){const n=P(e),s=n.readInt32BE(t),r=n.readUInt32BE(t+4);return Ne(s,r)}encode(e,t,n=0){const s=Pe(e),r=P(t);return r.writeInt32BE(s.hi32,n),r.writeUInt32BE(s.lo32,n+4),8}}l.NearInt64BE=Rt;class Et extends U{constructor(e){super(4,e)}decode(e,t=0){return P(e).readFloatLE(t)}encode(e,t,n=0){return P(t).writeFloatLE(e,n),4}}l.Float=Et;class Bt extends U{constructor(e){super(4,e)}decode(e,t=0){return P(e).readFloatBE(t)}encode(e,t,n=0){return P(t).writeFloatBE(e,n),4}}l.FloatBE=Bt;class xt extends U{constructor(e){super(8,e)}decode(e,t=0){return P(e).readDoubleLE(t)}encode(e,t,n=0){return P(t).writeDoubleLE(e,n),8}}l.Double=xt;class vt extends U{constructor(e){super(8,e)}decode(e,t=0){return P(e).readDoubleBE(t)}encode(e,t,n=0){return P(t).writeDoubleBE(e,n),8}}l.DoubleBE=vt;class Tt extends U{constructor(e,t,n){if(!(e instanceof U))throw new TypeError("elementLayout must be a Layout");if(!(t instanceof V&&t.isCount()||Number.isInteger(t)&&0<=t))throw new TypeError("count must be non-negative integer or an unsigned integer ExternalLayout");let s=-1;!(t instanceof V)&&0<e.span&&(s=t*e.span),super(s,n),this.elementLayout=e,this.count=t}getSpan(e,t=0){if(0<=this.span)return this.span;let n=0,s=this.count;if(s instanceof V&&(s=s.decode(e,t)),0<this.elementLayout.span)n=s*this.elementLayout.span;else{let r=0;for(;r<s;)n+=this.elementLayout.getSpan(e,t+n),++r}return n}decode(e,t=0){const n=[];let s=0,r=this.count;for(r instanceof V&&(r=r.decode(e,t));s<r;)n.push(this.elementLayout.decode(e,t)),t+=this.elementLayout.getSpan(e,t),s+=1;return n}encode(e,t,n=0){const s=this.elementLayout,r=e.reduce((o,a)=>o+s.encode(a,t,n+o),0);return this.count instanceof V&&this.count.encode(e.length,t,n),r}}l.Sequence=Tt;class Lt extends U{constructor(e,t,n){if(!(Array.isArray(e)&&e.reduce((r,o)=>r&&o instanceof U,!0)))throw new TypeError("fields must be array of Layout instances");typeof t=="boolean"&&n===void 0&&(n=t,t=void 0);for(const r of e)if(0>r.span&&r.property===void 0)throw new Error("fields cannot contain unnamed variable-length layout");let s=-1;try{s=e.reduce((r,o)=>r+o.getSpan(),0)}catch{}super(s,t),this.fields=e,this.decodePrefixes=!!n}getSpan(e,t=0){if(0<=this.span)return this.span;let n=0;try{n=this.fields.reduce((s,r)=>{const o=r.getSpan(e,t);return t+=o,s+o},0)}catch{throw new RangeError("indeterminate span")}return n}decode(e,t=0){be(e);const n=this.makeDestinationObject();for(const s of this.fields)if(s.property!==void 0&&(n[s.property]=s.decode(e,t)),t+=s.getSpan(e,t),this.decodePrefixes&&e.length===t)break;return n}encode(e,t,n=0){const s=n;let r=0,o=0;for(const a of this.fields){let c=a.span;if(o=0<c?c:0,a.property!==void 0){const g=e[a.property];g!==void 0&&(o=a.encode(g,t,n),0>c&&(c=a.getSpan(t,n)))}r=n,n+=c}return r+o-s}fromArray(e){const t=this.makeDestinationObject();for(const n of this.fields)n.property!==void 0&&0<e.length&&(t[n.property]=e.shift());return t}layoutFor(e){if(typeof e!="string")throw new TypeError("property must be string");for(const t of this.fields)if(t.property===e)return t}offsetOf(e){if(typeof e!="string")throw new TypeError("property must be string");let t=0;for(const n of this.fields){if(n.property===e)return t;0>n.span?t=-1:0<=t&&(t+=n.span)}}}l.Structure=Lt;class Ye{constructor(e){this.property=e}decode(e,t){throw new Error("UnionDiscriminator is abstract")}encode(e,t,n){throw new Error("UnionDiscriminator is abstract")}}l.UnionDiscriminator=Ye;class ve extends Ye{constructor(e,t){if(!(e instanceof V&&e.isCount()))throw new TypeError("layout must be an unsigned integer ExternalLayout");super(t||e.property||"variant"),this.layout=e}decode(e,t){return this.layout.decode(e,t)}encode(e,t,n){return this.layout.encode(e,t,n)}}l.UnionLayoutDiscriminator=ve;class Qe extends U{constructor(e,t,n){let s;if(e instanceof Q||e instanceof ee)s=new ve(new Ze(e));else if(e instanceof V&&e.isCount())s=new ve(e);else if(e instanceof Ye)s=e;else throw new TypeError("discr must be a UnionDiscriminator or an unsigned integer layout");if(t===void 0&&(t=null),!(t===null||t instanceof U))throw new TypeError("defaultLayout must be null or a Layout");if(t!==null){if(0>t.span)throw new Error("defaultLayout must have constant span");t.property===void 0&&(t=t.replicate("content"))}let r=-1;t&&(r=t.span,0<=r&&(e instanceof Q||e instanceof ee)&&(r+=s.layout.span)),super(r,n),this.discriminator=s,this.usesPrefixDiscriminator=e instanceof Q||e instanceof ee,this.defaultLayout=t,this.registry={};let o=this.defaultGetSourceVariant.bind(this);this.getSourceVariant=function(a){return o(a)},this.configGetSourceVariant=function(a){o=a.bind(this)}}getSpan(e,t=0){if(0<=this.span)return this.span;const n=this.getVariant(e,t);if(!n)throw new Error("unable to determine span for unrecognized variant");return n.getSpan(e,t)}defaultGetSourceVariant(e){if(Object.prototype.hasOwnProperty.call(e,this.discriminator.property)){if(this.defaultLayout&&this.defaultLayout.property&&Object.prototype.hasOwnProperty.call(e,this.defaultLayout.property))return;const t=this.registry[e[this.discriminator.property]];if(t&&(!t.layout||t.property&&Object.prototype.hasOwnProperty.call(e,t.property)))return t}else for(const t in this.registry){const n=this.registry[t];if(n.property&&Object.prototype.hasOwnProperty.call(e,n.property))return n}throw new Error("unable to infer src variant")}decode(e,t=0){let n;const s=this.discriminator,r=s.decode(e,t),o=this.registry[r];if(o===void 0){const a=this.defaultLayout;let c=0;this.usesPrefixDiscriminator&&(c=s.layout.span),n=this.makeDestinationObject(),n[s.property]=r,n[a.property]=a.decode(e,t+c)}else n=o.decode(e,t);return n}encode(e,t,n=0){const s=this.getSourceVariant(e);if(s===void 0){const r=this.discriminator,o=this.defaultLayout;let a=0;return this.usesPrefixDiscriminator&&(a=r.layout.span),r.encode(e[r.property],t,n),a+o.encode(e[o.property],t,n+a)}return s.encode(e,t,n)}addVariant(e,t,n){const s=new Ct(this,e,t,n);return this.registry[e]=s,s}getVariant(e,t=0){let n;return e instanceof Uint8Array?n=this.discriminator.decode(e,t):n=e,this.registry[n]}}l.Union=Qe;class Ct extends U{constructor(e,t,n,s){if(!(e instanceof Qe))throw new TypeError("union must be a Union");if(!Number.isInteger(t)||0>t)throw new TypeError("variant must be a (non-negative) integer");if(typeof n=="string"&&s===void 0&&(s=n,n=null),n){if(!(n instanceof U))throw new TypeError("layout must be a Layout");if(e.defaultLayout!==null&&0<=n.span&&n.span>e.defaultLayout.span)throw new Error("variant span exceeds span of containing union");if(typeof s!="string")throw new TypeError("variant must have a String property")}let r=e.span;0>e.span&&(r=n?n.span:0,0<=r&&e.usesPrefixDiscriminator&&(r+=e.discriminator.layout.span)),super(r,s),this.union=e,this.variant=t,this.layout=n||null}getSpan(e,t=0){if(0<=this.span)return this.span;let n=0;this.union.usesPrefixDiscriminator&&(n=this.union.discriminator.layout.span);let s=0;return this.layout&&(s=this.layout.getSpan(e,t+n)),n+s}decode(e,t=0){const n=this.makeDestinationObject();if(this!==this.union.getVariant(e,t))throw new Error("variant mismatch");let s=0;return this.union.usesPrefixDiscriminator&&(s=this.union.discriminator.layout.span),this.layout?n[this.property]=this.layout.decode(e,t+s):this.property?n[this.property]=!0:this.union.usesPrefixDiscriminator&&(n[this.union.discriminator.property]=this.variant),n}encode(e,t,n=0){let s=0;if(this.union.usesPrefixDiscriminator&&(s=this.union.discriminator.layout.span),this.layout&&!Object.prototype.hasOwnProperty.call(e,this.property))throw new TypeError("variant lacks property "+this.property);this.union.discriminator.encode(this.variant,t,n);let r=s;if(this.layout&&(this.layout.encode(e[this.property],t,n+s),r+=this.layout.getSpan(t,n+s),0<=this.union.span&&r>this.union.span))throw new Error("encoded variant overruns containing union");return r}fromArray(e){if(this.layout)return this.layout.fromArray(e)}}l.VariantLayout=Ct;function de(i){return 0>i&&(i+=4294967296),i}class et extends U{constructor(e,t,n){if(!(e instanceof Q||e instanceof ee))throw new TypeError("word must be a UInt or UIntBE layout");if(typeof t=="string"&&n===void 0&&(n=t,t=!1),4<e.span)throw new RangeError("word cannot exceed 32 bits");super(e.span,n),this.word=e,this.msb=!!t,this.fields=[];let s=0;this._packedSetValue=function(r){return s=de(r),this},this._packedGetValue=function(){return s}}decode(e,t=0){const n=this.makeDestinationObject(),s=this.word.decode(e,t);this._packedSetValue(s);for(const r of this.fields)r.property!==void 0&&(n[r.property]=r.decode(e));return n}encode(e,t,n=0){const s=this.word.decode(t,n);this._packedSetValue(s);for(const r of this.fields)if(r.property!==void 0){const o=e[r.property];o!==void 0&&r.encode(o)}return this.word.encode(this._packedGetValue(),t,n)}addField(e,t){const n=new tt(this,e,t);return this.fields.push(n),n}addBoolean(e){const t=new Pt(this,e);return this.fields.push(t),t}fieldFor(e){if(typeof e!="string")throw new TypeError("property must be string");for(const t of this.fields)if(t.property===e)return t}}l.BitStructure=et;class tt{constructor(e,t,n){if(!(e instanceof et))throw new TypeError("container must be a BitStructure");if(!Number.isInteger(t)||0>=t)throw new TypeError("bits must be positive integer");const s=8*e.span,r=e.fields.reduce((o,a)=>o+a.bits,0);if(t+r>s)throw new Error("bits too long for span remainder ("+(s-r)+" of "+s+" remain)");this.container=e,this.bits=t,this.valueMask=(1<<t)-1,t===32&&(this.valueMask=4294967295),this.start=r,this.container.msb&&(this.start=s-r-t),this.wordMask=de(this.valueMask<<this.start),this.property=n}decode(e,t){const n=this.container._packedGetValue();return de(n&this.wordMask)>>>this.start}encode(e){if(typeof e!="number"||!Number.isInteger(e)||e!==de(e&this.valueMask))throw new TypeError(Xe("BitField.encode",this)+" value must be integer not exceeding "+this.valueMask);const t=this.container._packedGetValue(),n=de(e<<this.start);this.container._packedSetValue(de(t&~this.wordMask)|n)}}l.BitField=tt;class Pt extends tt{constructor(e,t){super(e,1,t)}decode(e,t){return!!super.decode(e,t)}encode(e){typeof e=="boolean"&&(e=+e),super.encode(e)}}l.Boolean=Pt;class Nt extends U{constructor(e,t){if(!(e instanceof V&&e.isCount()||Number.isInteger(e)&&0<=e))throw new TypeError("length must be positive integer or an unsigned integer ExternalLayout");let n=-1;e instanceof V||(n=e),super(n,t),this.length=e}getSpan(e,t){let n=this.span;return 0>n&&(n=this.length.decode(e,t)),n}decode(e,t=0){let n=this.span;return 0>n&&(n=this.length.decode(e,t)),P(e).slice(t,t+n)}encode(e,t,n){let s=this.length;if(this.length instanceof V&&(s=e.length),!(e instanceof Uint8Array&&s===e.length))throw new TypeError(Xe("Blob.encode",this)+" requires (length "+s+") Uint8Array as src");if(n+s>t.length)throw new RangeError("encoding overruns Uint8Array");const r=P(e);return P(t).write(r.toString("hex"),n,s,"hex"),this.length instanceof V&&this.length.encode(s,t,n),s}}l.Blob=Nt;class Ut extends U{constructor(e){super(-1,e)}getSpan(e,t=0){be(e);let n=t;for(;n<e.length&&e[n]!==0;)n+=1;return 1+n-t}decode(e,t=0){const n=this.getSpan(e,t);return P(e).slice(t,t+n-1).toString("utf-8")}encode(e,t,n=0){typeof e!="string"&&(e=String(e));const s=Je.Buffer.from(e,"utf8"),r=s.length;if(n+r>t.length)throw new RangeError("encoding overruns Buffer");const o=P(t);return s.copy(o,n),o[n+r]=0,r+1}}l.CString=Ut;class Kt extends U{constructor(e,t){if(typeof e=="string"&&t===void 0&&(t=e,e=void 0),e===void 0)e=-1;else if(!Number.isInteger(e))throw new TypeError("maxSpan must be an integer");super(-1,t),this.maxSpan=e}getSpan(e,t=0){return be(e),e.length-t}decode(e,t=0){const n=this.getSpan(e,t);if(0<=this.maxSpan&&this.maxSpan<n)throw new RangeError("text length exceeds maxSpan");return P(e).slice(t,t+n).toString("utf-8")}encode(e,t,n=0){typeof e!="string"&&(e=String(e));const s=Je.Buffer.from(e,"utf8"),r=s.length;if(0<=this.maxSpan&&this.maxSpan<r)throw new RangeError("text length exceeds maxSpan");if(n+r>t.length)throw new RangeError("encoding overruns Buffer");return s.copy(P(t),n),r}}l.UTF8=Kt;class Ot extends U{constructor(e,t){super(0,t),this.value=e}decode(e,t){return this.value}encode(e,t,n){return 0}}l.Constant=Ot;l.greedy=(i,e)=>new kt(i,e);var ae=l.offset=(i,e,t)=>new Ze(i,e,t),N=l.u8=i=>new Q(1,i),J=l.u16=i=>new Q(2,i);l.u24=i=>new Q(3,i);var _=l.u32=i=>new Q(4,i);l.u40=i=>new Q(5,i);l.u48=i=>new Q(6,i);var W=l.nu64=i=>new It(i);l.u16be=i=>new ee(2,i);l.u24be=i=>new ee(3,i);l.u32be=i=>new ee(4,i);l.u40be=i=>new ee(5,i);l.u48be=i=>new ee(6,i);l.nu64be=i=>new _t(i);l.s8=i=>new ce(1,i);l.s16=i=>new ce(2,i);l.s24=i=>new ce(3,i);l.s32=i=>new ce(4,i);l.s40=i=>new ce(5,i);l.s48=i=>new ce(6,i);var $=l.ns64=i=>new At(i);l.s16be=i=>new we(2,i);l.s24be=i=>new we(3,i);l.s32be=i=>new we(4,i);l.s40be=i=>new we(5,i);l.s48be=i=>new we(6,i);l.ns64be=i=>new Rt(i);l.f32=i=>new Et(i);l.f32be=i=>new Bt(i);l.f64=i=>new xt(i);l.f64be=i=>new vt(i);var w=l.struct=(i,e,t)=>new Lt(i,e,t);l.bits=(i,e,t)=>new et(i,e,t);var G=l.seq=(i,e,t)=>new Tt(i,e,t);l.union=(i,e,t)=>new Qe(i,e,t);l.unionLayoutDiscriminator=(i,e)=>new ve(i,e);var F=l.blob=(i,e)=>new Nt(i,e);l.cstr=i=>new Ut(i);l.utf8=(i,e)=>new Kt(i,e);l.constant=(i,e)=>new Ot(i,e);function ct(i){try{return je.ExtendedPoint.fromHex(i),!0}catch{return!1}}const pn=(i,e)=>je.sign(i,e.slice(0,32)),gn=je.verify,ge=i=>v.Buffer.isBuffer(i)?i:i instanceof Uint8Array?v.Buffer.from(i.buffer,i.byteOffset,i.byteLength):v.Buffer.from(i);class mn{constructor(e){Object.assign(this,e)}encode(){return v.Buffer.from(sn(xe,this))}static decode(e){return rn(xe,this,e)}static decodeUnchecked(e){return on(xe,this,e)}}const xe=new Map;var qt;const yn=32,oe=32;function bn(i){return i._bn!==void 0}let ut=1;class B extends mn{constructor(e){if(super({}),this._bn=void 0,bn(e))this._bn=e._bn;else{if(typeof e=="string"){const t=z.decode(e);if(t.length!=oe)throw new Error("Invalid public key input");this._bn=new at(t)}else this._bn=new at(e);if(this._bn.byteLength()>oe)throw new Error("Invalid public key input")}}static unique(){const e=new B(ut);return ut+=1,new B(e.toBuffer())}equals(e){return this._bn.eq(e._bn)}toBase58(){return z.encode(this.toBytes())}toJSON(){return this.toBase58()}toBytes(){const e=this.toBuffer();return new Uint8Array(e.buffer,e.byteOffset,e.byteLength)}toBuffer(){const e=this._bn.toArrayLike(v.Buffer);if(e.length===oe)return e;const t=v.Buffer.alloc(32);return e.copy(t,32-e.length),t}get[Symbol.toStringTag](){return`PublicKey(${this.toString()})`}toString(){return this.toBase58()}static async createWithSeed(e,t,n){const s=v.Buffer.concat([e.toBuffer(),v.Buffer.from(t),n.toBuffer()]),r=it(s);return new B(r)}static createProgramAddressSync(e,t){let n=v.Buffer.alloc(0);e.forEach(function(r){if(r.length>yn)throw new TypeError("Max seed length exceeded");n=v.Buffer.concat([n,ge(r)])}),n=v.Buffer.concat([n,t.toBuffer(),v.Buffer.from("ProgramDerivedAddress")]);const s=it(n);if(ct(s))throw new Error("Invalid seeds, address must fall off the curve");return new B(s)}static async createProgramAddress(e,t){return this.createProgramAddressSync(e,t)}static findProgramAddressSync(e,t){let n=255,s;for(;n!=0;){try{const r=e.concat(v.Buffer.from([n]));s=this.createProgramAddressSync(r,t)}catch(r){if(r instanceof TypeError)throw r;n--;continue}return[s,n]}throw new Error("Unable to find a viable program address nonce")}static async findProgramAddress(e,t){return this.findProgramAddressSync(e,t)}static isOnCurve(e){const t=new B(e);return ct(t.toBytes())}}qt=B;B.default=new qt("11111111111111111111111111111111");xe.set(B,{kind:"struct",fields:[["_bn","u256"]]});new B("BPFLoader1111111111111111111111111111111111");const pe=1232,Ft=127,Mt=64;class Dt extends Error{constructor(e){super(`Signature ${e} has expired: block height exceeded.`),this.signature=void 0,this.signature=e}}Object.defineProperty(Dt.prototype,"name",{value:"TransactionExpiredBlockheightExceededError"});class Wt extends Error{constructor(e,t){super(`Transaction was not confirmed in ${t.toFixed(2)} seconds. It is unknown if it succeeded or failed. Check signature ${e} using the Solana Explorer or CLI tools.`),this.signature=void 0,this.signature=e}}Object.defineProperty(Wt.prototype,"name",{value:"TransactionExpiredTimeoutError"});class _e extends Error{constructor(e){super(`Signature ${e} has expired: the nonce is no longer valid.`),this.signature=void 0,this.signature=e}}Object.defineProperty(_e.prototype,"name",{value:"TransactionExpiredNonceInvalidError"});class Te{constructor(e,t){this.staticAccountKeys=void 0,this.accountKeysFromLookups=void 0,this.staticAccountKeys=e,this.accountKeysFromLookups=t}keySegments(){const e=[this.staticAccountKeys];return this.accountKeysFromLookups&&(e.push(this.accountKeysFromLookups.writable),e.push(this.accountKeysFromLookups.readonly)),e}get(e){for(const t of this.keySegments()){if(e<t.length)return t[e];e-=t.length}}get length(){return this.keySegments().flat().length}compileInstructions(e){if(this.length>256)throw new Error("Account index overflow encountered during compilation");const n=new Map;this.keySegments().flat().forEach((r,o)=>{n.set(r.toBase58(),o)});const s=r=>{const o=n.get(r.toBase58());if(o===void 0)throw new Error("Encountered an unknown instruction account key during compilation");return o};return e.map(r=>({programIdIndex:s(r.programId),accountKeyIndexes:r.keys.map(o=>s(o.pubkey)),data:r.data}))}}const L=(i="publicKey")=>F(32,i),fe=(i="string")=>{const e=w([_("length"),_("lengthPadding"),F(ae(_(),-8),"chars")],i),t=e.decode.bind(e),n=e.encode.bind(e),s=e;return s.decode=(r,o)=>t(r,o).chars.toString(),s.encode=(r,o,a)=>{const c={chars:v.Buffer.from(r,"utf8")};return n(c,o,a)},s.alloc=r=>_().span+_().span+v.Buffer.from(r,"utf8").length,s},wn=(i="authorized")=>w([L("staker"),L("withdrawer")],i),Sn=(i="lockup")=>w([$("unixTimestamp"),$("epoch"),L("custodian")],i),kn=(i="voteInit")=>w([L("nodePubkey"),L("authorizedVoter"),L("authorizedWithdrawer"),N("commission")],i),In=(i="voteAuthorizeWithSeedArgs")=>w([_("voteAuthorizationType"),L("currentAuthorityDerivedKeyOwnerPubkey"),fe("currentAuthorityDerivedKeySeed"),L("newAuthorized")],i);function X(i){let e=0,t=0;for(;;){let n=i.shift();if(e|=(n&127)<<t*7,t+=1,!(n&128))break}return e}function Z(i,e){let t=e;for(;;){let n=t&127;if(t>>=7,t==0){i.push(n);break}else n|=128,i.push(n)}}function D(i,e){if(!i)throw new Error(e||"Assertion failed")}class Ue{constructor(e,t){this.payer=void 0,this.keyMetaMap=void 0,this.payer=e,this.keyMetaMap=t}static compile(e,t){const n=new Map,s=o=>{const a=o.toBase58();let c=n.get(a);return c===void 0&&(c={isSigner:!1,isWritable:!1,isInvoked:!1},n.set(a,c)),c},r=s(t);r.isSigner=!0,r.isWritable=!0;for(const o of e){s(o.programId).isInvoked=!0;for(const a of o.keys){const c=s(a.pubkey);c.isSigner||(c.isSigner=a.isSigner),c.isWritable||(c.isWritable=a.isWritable)}}return new Ue(t,n)}getMessageComponents(){const e=[...this.keyMetaMap.entries()];D(e.length<=256,"Max static account keys length exceeded");const t=e.filter(([,c])=>c.isSigner&&c.isWritable),n=e.filter(([,c])=>c.isSigner&&!c.isWritable),s=e.filter(([,c])=>!c.isSigner&&c.isWritable),r=e.filter(([,c])=>!c.isSigner&&!c.isWritable),o={numRequiredSignatures:t.length+n.length,numReadonlySignedAccounts:n.length,numReadonlyUnsignedAccounts:r.length};{D(t.length>0,"Expected at least one writable signer key");const[c]=t[0];D(c===this.payer.toBase58(),"Expected first writable signer key to be the fee payer")}const a=[...t.map(([c])=>new B(c)),...n.map(([c])=>new B(c)),...s.map(([c])=>new B(c)),...r.map(([c])=>new B(c))];return[o,a]}extractTableLookup(e){const[t,n]=this.drainKeysFoundInLookupTable(e.state.addresses,o=>!o.isSigner&&!o.isInvoked&&o.isWritable),[s,r]=this.drainKeysFoundInLookupTable(e.state.addresses,o=>!o.isSigner&&!o.isInvoked&&!o.isWritable);if(!(t.length===0&&s.length===0))return[{accountKey:e.key,writableIndexes:t,readonlyIndexes:s},{writable:n,readonly:r}]}drainKeysFoundInLookupTable(e,t){const n=new Array,s=new Array;for(const[r,o]of this.keyMetaMap.entries())if(t(o)){const a=new B(r),c=e.findIndex(g=>g.equals(a));c>=0&&(D(c<256,"Max lookup table index exceeded"),n.push(c),s.push(a),this.keyMetaMap.delete(r))}return[n,s]}}const zt="Reached end of buffer unexpectedly";function ne(i){if(i.length===0)throw new Error(zt);return i.shift()}function Y(i,...e){const[t]=e;if(e.length===2?t+(e[1]??0)>i.length:t>=i.length)throw new Error(zt);return i.splice(...e)}class ie{constructor(e){this.header=void 0,this.accountKeys=void 0,this.recentBlockhash=void 0,this.instructions=void 0,this.indexToProgramIds=new Map,this.header=e.header,this.accountKeys=e.accountKeys.map(t=>new B(t)),this.recentBlockhash=e.recentBlockhash,this.instructions=e.instructions,this.instructions.forEach(t=>this.indexToProgramIds.set(t.programIdIndex,this.accountKeys[t.programIdIndex]))}get version(){return"legacy"}get staticAccountKeys(){return this.accountKeys}get compiledInstructions(){return this.instructions.map(e=>({programIdIndex:e.programIdIndex,accountKeyIndexes:e.accounts,data:z.decode(e.data)}))}get addressTableLookups(){return[]}getAccountKeys(){return new Te(this.staticAccountKeys)}static compile(e){const t=Ue.compile(e.instructions,e.payerKey),[n,s]=t.getMessageComponents(),o=new Te(s).compileInstructions(e.instructions).map(a=>({programIdIndex:a.programIdIndex,accounts:a.accountKeyIndexes,data:z.encode(a.data)}));return new ie({header:n,accountKeys:s,recentBlockhash:e.recentBlockhash,instructions:o})}isAccountSigner(e){return e<this.header.numRequiredSignatures}isAccountWritable(e){const t=this.header.numRequiredSignatures;if(e>=this.header.numRequiredSignatures){const n=e-t,r=this.accountKeys.length-t-this.header.numReadonlyUnsignedAccounts;return n<r}else{const n=t-this.header.numReadonlySignedAccounts;return e<n}}isProgramId(e){return this.indexToProgramIds.has(e)}programIds(){return[...this.indexToProgramIds.values()]}nonProgramIds(){return this.accountKeys.filter((e,t)=>!this.isProgramId(t))}serialize(){const e=this.accountKeys.length;let t=[];Z(t,e);const n=this.instructions.map(E=>{const{accounts:T,programIdIndex:k}=E,b=Array.from(z.decode(E.data));let p=[];Z(p,T.length);let I=[];return Z(I,b.length),{programIdIndex:k,keyIndicesCount:v.Buffer.from(p),keyIndices:T,dataLength:v.Buffer.from(I),data:b}});let s=[];Z(s,n.length);let r=v.Buffer.alloc(pe);v.Buffer.from(s).copy(r);let o=s.length;n.forEach(E=>{const k=w([N("programIdIndex"),F(E.keyIndicesCount.length,"keyIndicesCount"),G(N("keyIndex"),E.keyIndices.length,"keyIndices"),F(E.dataLength.length,"dataLength"),G(N("userdatum"),E.data.length,"data")]).encode(E,r,o);o+=k}),r=r.slice(0,o);const a=w([F(1,"numRequiredSignatures"),F(1,"numReadonlySignedAccounts"),F(1,"numReadonlyUnsignedAccounts"),F(t.length,"keyCount"),G(L("key"),e,"keys"),L("recentBlockhash")]),c={numRequiredSignatures:v.Buffer.from([this.header.numRequiredSignatures]),numReadonlySignedAccounts:v.Buffer.from([this.header.numReadonlySignedAccounts]),numReadonlyUnsignedAccounts:v.Buffer.from([this.header.numReadonlyUnsignedAccounts]),keyCount:v.Buffer.from(t),keys:this.accountKeys.map(E=>ge(E.toBytes())),recentBlockhash:z.decode(this.recentBlockhash)};let g=v.Buffer.alloc(2048);const R=a.encode(c,g);return r.copy(g,R),g.slice(0,R+r.length)}static from(e){let t=[...e];const n=ne(t);if(n!==(n&Ft))throw new Error("Versioned messages must be deserialized with VersionedMessage.deserialize()");const s=ne(t),r=ne(t),o=X(t);let a=[];for(let T=0;T<o;T++){const k=Y(t,0,oe);a.push(new B(v.Buffer.from(k)))}const c=Y(t,0,oe),g=X(t);let R=[];for(let T=0;T<g;T++){const k=ne(t),b=X(t),p=Y(t,0,b),I=X(t),C=Y(t,0,I),H=z.encode(v.Buffer.from(C));R.push({programIdIndex:k,accounts:p,data:H})}const E={header:{numRequiredSignatures:n,numReadonlySignedAccounts:s,numReadonlyUnsignedAccounts:r},recentBlockhash:z.encode(v.Buffer.from(c)),accountKeys:a,instructions:R};return new ie(E)}}class Le{constructor(e){this.header=void 0,this.staticAccountKeys=void 0,this.recentBlockhash=void 0,this.compiledInstructions=void 0,this.addressTableLookups=void 0,this.header=e.header,this.staticAccountKeys=e.staticAccountKeys,this.recentBlockhash=e.recentBlockhash,this.compiledInstructions=e.compiledInstructions,this.addressTableLookups=e.addressTableLookups}get version(){return 0}get numAccountKeysFromLookups(){let e=0;for(const t of this.addressTableLookups)e+=t.readonlyIndexes.length+t.writableIndexes.length;return e}getAccountKeys(e){let t;if(e&&"accountKeysFromLookups"in e&&e.accountKeysFromLookups){if(this.numAccountKeysFromLookups!=e.accountKeysFromLookups.writable.length+e.accountKeysFromLookups.readonly.length)throw new Error("Failed to get account keys because of a mismatch in the number of account keys from lookups");t=e.accountKeysFromLookups}else if(e&&"addressLookupTableAccounts"in e&&e.addressLookupTableAccounts)t=this.resolveAddressTableLookups(e.addressLookupTableAccounts);else if(this.addressTableLookups.length>0)throw new Error("Failed to get account keys because address table lookups were not resolved");return new Te(this.staticAccountKeys,t)}isAccountSigner(e){return e<this.header.numRequiredSignatures}isAccountWritable(e){const t=this.header.numRequiredSignatures,n=this.staticAccountKeys.length;if(e>=n){const s=e-n,r=this.addressTableLookups.reduce((o,a)=>o+a.writableIndexes.length,0);return s<r}else if(e>=this.header.numRequiredSignatures){const s=e-t,o=n-t-this.header.numReadonlyUnsignedAccounts;return s<o}else{const s=t-this.header.numReadonlySignedAccounts;return e<s}}resolveAddressTableLookups(e){const t={writable:[],readonly:[]};for(const n of this.addressTableLookups){const s=e.find(r=>r.key.equals(n.accountKey));if(!s)throw new Error(`Failed to find address lookup table account for table key ${n.accountKey.toBase58()}`);for(const r of n.writableIndexes)if(r<s.state.addresses.length)t.writable.push(s.state.addresses[r]);else throw new Error(`Failed to find address for index ${r} in address lookup table ${n.accountKey.toBase58()}`);for(const r of n.readonlyIndexes)if(r<s.state.addresses.length)t.readonly.push(s.state.addresses[r]);else throw new Error(`Failed to find address for index ${r} in address lookup table ${n.accountKey.toBase58()}`)}return t}static compile(e){const t=Ue.compile(e.instructions,e.payerKey),n=new Array,s={writable:new Array,readonly:new Array},r=e.addressLookupTableAccounts||[];for(const R of r){const E=t.extractTableLookup(R);if(E!==void 0){const[T,{writable:k,readonly:b}]=E;n.push(T),s.writable.push(...k),s.readonly.push(...b)}}const[o,a]=t.getMessageComponents(),g=new Te(a,s).compileInstructions(e.instructions);return new Le({header:o,staticAccountKeys:a,recentBlockhash:e.recentBlockhash,compiledInstructions:g,addressTableLookups:n})}serialize(){const e=Array();Z(e,this.staticAccountKeys.length);const t=this.serializeInstructions(),n=Array();Z(n,this.compiledInstructions.length);const s=this.serializeAddressTableLookups(),r=Array();Z(r,this.addressTableLookups.length);const o=w([N("prefix"),w([N("numRequiredSignatures"),N("numReadonlySignedAccounts"),N("numReadonlyUnsignedAccounts")],"header"),F(e.length,"staticAccountKeysLength"),G(L(),this.staticAccountKeys.length,"staticAccountKeys"),L("recentBlockhash"),F(n.length,"instructionsLength"),F(t.length,"serializedInstructions"),F(r.length,"addressTableLookupsLength"),F(s.length,"serializedAddressTableLookups")]),a=new Uint8Array(pe),g=o.encode({prefix:128,header:this.header,staticAccountKeysLength:new Uint8Array(e),staticAccountKeys:this.staticAccountKeys.map(R=>R.toBytes()),recentBlockhash:z.decode(this.recentBlockhash),instructionsLength:new Uint8Array(n),serializedInstructions:t,addressTableLookupsLength:new Uint8Array(r),serializedAddressTableLookups:s},a);return a.slice(0,g)}serializeInstructions(){let e=0;const t=new Uint8Array(pe);for(const n of this.compiledInstructions){const s=Array();Z(s,n.accountKeyIndexes.length);const r=Array();Z(r,n.data.length);const o=w([N("programIdIndex"),F(s.length,"encodedAccountKeyIndexesLength"),G(N(),n.accountKeyIndexes.length,"accountKeyIndexes"),F(r.length,"encodedDataLength"),F(n.data.length,"data")]);e+=o.encode({programIdIndex:n.programIdIndex,encodedAccountKeyIndexesLength:new Uint8Array(s),accountKeyIndexes:n.accountKeyIndexes,encodedDataLength:new Uint8Array(r),data:n.data},t,e)}return t.slice(0,e)}serializeAddressTableLookups(){let e=0;const t=new Uint8Array(pe);for(const n of this.addressTableLookups){const s=Array();Z(s,n.writableIndexes.length);const r=Array();Z(r,n.readonlyIndexes.length);const o=w([L("accountKey"),F(s.length,"encodedWritableIndexesLength"),G(N(),n.writableIndexes.length,"writableIndexes"),F(r.length,"encodedReadonlyIndexesLength"),G(N(),n.readonlyIndexes.length,"readonlyIndexes")]);e+=o.encode({accountKey:n.accountKey.toBytes(),encodedWritableIndexesLength:new Uint8Array(s),writableIndexes:n.writableIndexes,encodedReadonlyIndexesLength:new Uint8Array(r),readonlyIndexes:n.readonlyIndexes},t,e)}return t.slice(0,e)}static deserialize(e){let t=[...e];const n=ne(t),s=n&Ft;D(n!==s,"Expected versioned message but received legacy message");const r=s;D(r===0,`Expected versioned message with version 0 but found version ${r}`);const o={numRequiredSignatures:ne(t),numReadonlySignedAccounts:ne(t),numReadonlyUnsignedAccounts:ne(t)},a=[],c=X(t);for(let b=0;b<c;b++)a.push(new B(Y(t,0,oe)));const g=z.encode(Y(t,0,oe)),R=X(t),E=[];for(let b=0;b<R;b++){const p=ne(t),I=X(t),C=Y(t,0,I),H=X(t),ke=new Uint8Array(Y(t,0,H));E.push({programIdIndex:p,accountKeyIndexes:C,data:ke})}const T=X(t),k=[];for(let b=0;b<T;b++){const p=new B(Y(t,0,oe)),I=X(t),C=Y(t,0,I),H=X(t),ke=Y(t,0,H);k.push({accountKey:p,writableIndexes:C,readonlyIndexes:ke})}return new Le({header:o,staticAccountKeys:a,recentBlockhash:g,compiledInstructions:E,addressTableLookups:k})}}let se=function(i){return i[i.BLOCKHEIGHT_EXCEEDED=0]="BLOCKHEIGHT_EXCEEDED",i[i.PROCESSED=1]="PROCESSED",i[i.TIMED_OUT=2]="TIMED_OUT",i[i.NONCE_INVALID=3]="NONCE_INVALID",i}({});const _n=v.Buffer.alloc(Mt).fill(0);class lt{constructor(e){this.keys=void 0,this.programId=void 0,this.data=v.Buffer.alloc(0),this.programId=e.programId,this.keys=e.keys,e.data&&(this.data=e.data)}toJSON(){return{keys:this.keys.map(({pubkey:e,isSigner:t,isWritable:n})=>({pubkey:e.toJSON(),isSigner:t,isWritable:n})),programId:this.programId.toJSON(),data:[...this.data]}}}class re{get signature(){return this.signatures.length>0?this.signatures[0].signature:null}constructor(e){if(this.signatures=[],this.feePayer=void 0,this.instructions=[],this.recentBlockhash=void 0,this.lastValidBlockHeight=void 0,this.nonceInfo=void 0,this.minNonceContextSlot=void 0,this._message=void 0,this._json=void 0,!!e)if(e.feePayer&&(this.feePayer=e.feePayer),e.signatures&&(this.signatures=e.signatures),Object.prototype.hasOwnProperty.call(e,"nonceInfo")){const{minContextSlot:t,nonceInfo:n}=e;this.minNonceContextSlot=t,this.nonceInfo=n}else if(Object.prototype.hasOwnProperty.call(e,"lastValidBlockHeight")){const{blockhash:t,lastValidBlockHeight:n}=e;this.recentBlockhash=t,this.lastValidBlockHeight=n}else{const{recentBlockhash:t,nonceInfo:n}=e;n&&(this.nonceInfo=n),this.recentBlockhash=t}}toJSON(){return{recentBlockhash:this.recentBlockhash||null,feePayer:this.feePayer?this.feePayer.toJSON():null,nonceInfo:this.nonceInfo?{nonce:this.nonceInfo.nonce,nonceInstruction:this.nonceInfo.nonceInstruction.toJSON()}:null,instructions:this.instructions.map(e=>e.toJSON()),signers:this.signatures.map(({publicKey:e})=>e.toJSON())}}add(...e){if(e.length===0)throw new Error("No instructions");return e.forEach(t=>{"instructions"in t?this.instructions=this.instructions.concat(t.instructions):"data"in t&&"programId"in t&&"keys"in t?this.instructions.push(t):this.instructions.push(new lt(t))}),this}compileMessage(){if(this._message&&JSON.stringify(this.toJSON())===JSON.stringify(this._json))return this._message;let e,t;if(this.nonceInfo?(e=this.nonceInfo.nonce,this.instructions[0]!=this.nonceInfo.nonceInstruction?t=[this.nonceInfo.nonceInstruction,...this.instructions]:t=this.instructions):(e=this.recentBlockhash,t=this.instructions),!e)throw new Error("Transaction recentBlockhash required");t.length<1&&console.warn("No instructions provided");let n;if(this.feePayer)n=this.feePayer;else if(this.signatures.length>0&&this.signatures[0].publicKey)n=this.signatures[0].publicKey;else throw new Error("Transaction fee payer required");for(let p=0;p<t.length;p++)if(t[p].programId===void 0)throw new Error(`Transaction instruction index ${p} has undefined program id`);const s=[],r=[];t.forEach(p=>{p.keys.forEach(C=>{r.push({...C})});const I=p.programId.toString();s.includes(I)||s.push(I)}),s.forEach(p=>{r.push({pubkey:new B(p),isSigner:!1,isWritable:!1})});const o=[];r.forEach(p=>{const I=p.pubkey.toString(),C=o.findIndex(H=>H.pubkey.toString()===I);C>-1?(o[C].isWritable=o[C].isWritable||p.isWritable,o[C].isSigner=o[C].isSigner||p.isSigner):o.push(p)}),o.sort(function(p,I){if(p.isSigner!==I.isSigner)return p.isSigner?-1:1;if(p.isWritable!==I.isWritable)return p.isWritable?-1:1;const C={localeMatcher:"best fit",usage:"sort",sensitivity:"variant",ignorePunctuation:!1,numeric:!1,caseFirst:"lower"};return p.pubkey.toBase58().localeCompare(I.pubkey.toBase58(),"en",C)});const a=o.findIndex(p=>p.pubkey.equals(n));if(a>-1){const[p]=o.splice(a,1);p.isSigner=!0,p.isWritable=!0,o.unshift(p)}else o.unshift({pubkey:n,isSigner:!0,isWritable:!0});for(const p of this.signatures){const I=o.findIndex(C=>C.pubkey.equals(p.publicKey));if(I>-1)o[I].isSigner||(o[I].isSigner=!0,console.warn("Transaction references a signature that is unnecessary, only the fee payer and instruction signer accounts should sign a transaction. This behavior is deprecated and will throw an error in the next major version release."));else throw new Error(`unknown signer: ${p.publicKey.toString()}`)}let c=0,g=0,R=0;const E=[],T=[];o.forEach(({pubkey:p,isSigner:I,isWritable:C})=>{I?(E.push(p.toString()),c+=1,C||(g+=1)):(T.push(p.toString()),C||(R+=1))});const k=E.concat(T),b=t.map(p=>{const{data:I,programId:C}=p;return{programIdIndex:k.indexOf(C.toString()),accounts:p.keys.map(H=>k.indexOf(H.pubkey.toString())),data:z.encode(I)}});return b.forEach(p=>{D(p.programIdIndex>=0),p.accounts.forEach(I=>D(I>=0))}),new ie({header:{numRequiredSignatures:c,numReadonlySignedAccounts:g,numReadonlyUnsignedAccounts:R},accountKeys:k,recentBlockhash:e,instructions:b})}_compile(){const e=this.compileMessage(),t=e.accountKeys.slice(0,e.header.numRequiredSignatures);return this.signatures.length===t.length&&this.signatures.every((s,r)=>t[r].equals(s.publicKey))||(this.signatures=t.map(n=>({signature:null,publicKey:n}))),e}serializeMessage(){return this._compile().serialize()}async getEstimatedFee(e){return(await e.getFeeForMessage(this.compileMessage())).value}setSigners(...e){if(e.length===0)throw new Error("No signers");const t=new Set;this.signatures=e.filter(n=>{const s=n.toString();return t.has(s)?!1:(t.add(s),!0)}).map(n=>({signature:null,publicKey:n}))}sign(...e){if(e.length===0)throw new Error("No signers");const t=new Set,n=[];for(const r of e){const o=r.publicKey.toString();t.has(o)||(t.add(o),n.push(r))}this.signatures=n.map(r=>({signature:null,publicKey:r.publicKey}));const s=this._compile();this._partialSign(s,...n)}partialSign(...e){if(e.length===0)throw new Error("No signers");const t=new Set,n=[];for(const r of e){const o=r.publicKey.toString();t.has(o)||(t.add(o),n.push(r))}const s=this._compile();this._partialSign(s,...n)}_partialSign(e,...t){const n=e.serialize();t.forEach(s=>{const r=pn(n,s.secretKey);this._addSignature(s.publicKey,ge(r))})}addSignature(e,t){this._compile(),this._addSignature(e,t)}_addSignature(e,t){D(t.length===64);const n=this.signatures.findIndex(s=>e.equals(s.publicKey));if(n<0)throw new Error(`unknown signer: ${e.toString()}`);this.signatures[n].signature=v.Buffer.from(t)}verifySignatures(e=!0){return!this._getMessageSignednessErrors(this.serializeMessage(),e)}_getMessageSignednessErrors(e,t){const n={};for(const{signature:s,publicKey:r}of this.signatures)s===null?t&&(n.missing||(n.missing=[])).push(r):gn(s,e,r.toBytes())||(n.invalid||(n.invalid=[])).push(r);return n.invalid||n.missing?n:void 0}serialize(e){const{requireAllSignatures:t,verifySignatures:n}=Object.assign({requireAllSignatures:!0,verifySignatures:!0},e),s=this.serializeMessage();if(n){const r=this._getMessageSignednessErrors(s,t);if(r){let o="Signature verification failed.";throw r.invalid&&(o+=`
Invalid signature for public key${r.invalid.length===1?"":"(s)"} [\`${r.invalid.map(a=>a.toBase58()).join("`, `")}\`].`),r.missing&&(o+=`
Missing signature for public key${r.missing.length===1?"":"(s)"} [\`${r.missing.map(a=>a.toBase58()).join("`, `")}\`].`),new Error(o)}}return this._serialize(s)}_serialize(e){const{signatures:t}=this,n=[];Z(n,t.length);const s=n.length+t.length*64+e.length,r=v.Buffer.alloc(s);return D(t.length<256),v.Buffer.from(n).copy(r,0),t.forEach(({signature:o},a)=>{o!==null&&(D(o.length===64,"signature has invalid length"),v.Buffer.from(o).copy(r,n.length+a*64))}),e.copy(r,n.length+t.length*64),D(r.length<=pe,`Transaction too large: ${r.length} > ${pe}`),r}get keys(){return D(this.instructions.length===1),this.instructions[0].keys.map(e=>e.pubkey)}get programId(){return D(this.instructions.length===1),this.instructions[0].programId}get data(){return D(this.instructions.length===1),this.instructions[0].data}static from(e){let t=[...e];const n=X(t);let s=[];for(let r=0;r<n;r++){const o=Y(t,0,Mt);s.push(z.encode(v.Buffer.from(o)))}return re.populate(ie.from(t),s)}static populate(e,t=[]){const n=new re;return n.recentBlockhash=e.recentBlockhash,e.header.numRequiredSignatures>0&&(n.feePayer=e.accountKeys[0]),t.forEach((s,r)=>{const o={signature:s==z.encode(_n)?null:z.decode(s),publicKey:e.accountKeys[r]};n.signatures.push(o)}),e.instructions.forEach(s=>{const r=s.accounts.map(o=>{const a=e.accountKeys[o];return{pubkey:a,isSigner:n.signatures.some(c=>c.publicKey.toString()===a.toString())||e.isAccountSigner(o),isWritable:e.isAccountWritable(o)}});n.instructions.push(new lt({keys:r,programId:e.accountKeys[s.programIdIndex],data:z.decode(s.data)}))}),n._message=e,n._json=n.toJSON(),n}}const An=160,Rn=64,En=An/Rn,Bn=1e3/En;new B("SysvarC1ock11111111111111111111111111111111");new B("SysvarEpochSchedu1e111111111111111111111111");new B("Sysvar1nstructions1111111111111111111111111");new B("SysvarRecentB1ockHashes11111111111111111111");new B("SysvarRent111111111111111111111111111111111");new B("SysvarRewards111111111111111111111111111111");new B("SysvarS1otHashes111111111111111111111111111");new B("SysvarS1otHistory11111111111111111111111111");new B("SysvarStakeHistory1111111111111111111111111");class dt extends Error{constructor({action:e,signature:t,transactionMessage:n,logs:s}){const r=s?`Logs: 
${JSON.stringify(s.slice(-10),null,2)}. `:"",o="\nCatch the `SendTransactionError` and call `getLogs()` on it for full details.";let a;switch(e){case"send":a=`Transaction ${t} resulted in an error. 
${n}. `+r+o;break;case"simulate":a=`Simulation failed. 
Message: ${n}. 
`+r+o;break;default:a=`Unknown action '${(c=>c)(e)}'`}super(a),this.signature=void 0,this.transactionMessage=void 0,this.transactionLogs=void 0,this.signature=t,this.transactionMessage=n,this.transactionLogs=s||void 0}get transactionError(){return{message:this.transactionMessage,logs:Array.isArray(this.transactionLogs)?this.transactionLogs:void 0}}get logs(){const e=this.transactionLogs;if(!(e!=null&&typeof e=="object"&&"then"in e))return e}async getLogs(e){return Array.isArray(this.transactionLogs)||(this.transactionLogs=new Promise((t,n)=>{e.getTransaction(this.signature).then(s=>{if(s&&s.meta&&s.meta.logMessages){const r=s.meta.logMessages;this.transactionLogs=r,t(r)}else n(new Error("Log messages not found"))}).catch(n)})),await this.transactionLogs}}class S extends Error{constructor({code:e,message:t,data:n},s){super(s!=null?`${s}: ${t}`:t),this.code=void 0,this.data=void 0,this.code=e,this.data=n,this.name="SolanaJSONRPCError"}}function he(i){return new Promise(e=>setTimeout(e,i))}const xn=W("lamportsPerSignature"),Ht=w([_("version"),_("state"),L("authorizedPubkey"),L("nonce"),w([xn],"feeCalculator")]);Ht.span;class nt{constructor(e){this.authorizedPubkey=void 0,this.nonce=void 0,this.feeCalculator=void 0,this.authorizedPubkey=e.authorizedPubkey,this.nonce=e.nonce,this.feeCalculator=e.feeCalculator}static fromAccountData(e){const t=Ht.decode(ge(e),0);return new nt({authorizedPubkey:new B(t.authorizedPubkey),nonce:new B(t.nonce).toString(),feeCalculator:t.feeCalculator})}}const vn=i=>{const e=i.decode.bind(i),t=i.encode.bind(i);return{decode:e,encode:t}},Tn=i=>e=>{const t=F(i,e),{encode:n,decode:s}=vn(t),r=t;return r.decode=(o,a)=>{const c=s(o,a);return an(v.Buffer.from(c))},r.encode=(o,a,c)=>{const g=cn(o,i);return n(g,a,c)},r},me=Tn(8);Object.freeze({Create:{index:0,layout:w([_("instruction"),$("lamports"),$("space"),L("programId")])},Assign:{index:1,layout:w([_("instruction"),L("programId")])},Transfer:{index:2,layout:w([_("instruction"),me("lamports")])},CreateWithSeed:{index:3,layout:w([_("instruction"),L("base"),fe("seed"),$("lamports"),$("space"),L("programId")])},AdvanceNonceAccount:{index:4,layout:w([_("instruction")])},WithdrawNonceAccount:{index:5,layout:w([_("instruction"),$("lamports")])},InitializeNonceAccount:{index:6,layout:w([_("instruction"),L("authorized")])},AuthorizeNonceAccount:{index:7,layout:w([_("instruction"),L("authorized")])},Allocate:{index:8,layout:w([_("instruction"),$("space")])},AllocateWithSeed:{index:9,layout:w([_("instruction"),L("base"),fe("seed"),$("space"),L("programId")])},AssignWithSeed:{index:10,layout:w([_("instruction"),L("base"),fe("seed"),L("programId")])},TransferWithSeed:{index:11,layout:w([_("instruction"),me("lamports"),fe("seed"),L("programId")])},UpgradeNonceAccount:{index:12,layout:w([_("instruction")])}});new B("11111111111111111111111111111111");new B("BPFLoader2111111111111111111111111111111111");function Ln(i){return i&&i.__esModule&&Object.prototype.hasOwnProperty.call(i,"default")?i.default:i}var Cn=Object.prototype.toString,Pn=Object.keys||function(i){var e=[];for(var t in i)e.push(t);return e};function Ae(i,e){var t,n,s,r,o,a,c;if(i===!0)return"true";if(i===!1)return"false";switch(typeof i){case"object":if(i===null)return null;if(i.toJSON&&typeof i.toJSON=="function")return Ae(i.toJSON(),e);if(c=Cn.call(i),c==="[object Array]"){for(s="[",n=i.length-1,t=0;t<n;t++)s+=Ae(i[t],!0)+",";return n>-1&&(s+=Ae(i[t],!0)),s+"]"}else if(c==="[object Object]"){for(r=Pn(i).sort(),n=r.length,s="",t=0;t<n;)o=r[t],a=Ae(i[o],!1),a!==void 0&&(s&&(s+=","),s+=JSON.stringify(o)+":"+a),t++;return"{"+s+"}"}else return JSON.stringify(i);case"function":case"undefined":return e?null:void 0;case"string":return JSON.stringify(i);default:return isFinite(i)?i:null}}var Nn=function(i){var e=Ae(i,!1);if(e!==void 0)return""+e},ht=Ln(Nn);const Ie=32;function Fe(i){let e=0;for(;i>1;)i/=2,e++;return e}function Un(i){return i===0?1:(i--,i|=i>>1,i|=i>>2,i|=i>>4,i|=i>>8,i|=i>>16,i|=i>>32,i+1)}class Kn{constructor(e,t,n,s,r){this.slotsPerEpoch=void 0,this.leaderScheduleSlotOffset=void 0,this.warmup=void 0,this.firstNormalEpoch=void 0,this.firstNormalSlot=void 0,this.slotsPerEpoch=e,this.leaderScheduleSlotOffset=t,this.warmup=n,this.firstNormalEpoch=s,this.firstNormalSlot=r}getEpoch(e){return this.getEpochAndSlotIndex(e)[0]}getEpochAndSlotIndex(e){if(e<this.firstNormalSlot){const t=Fe(Un(e+Ie+1))-Fe(Ie)-1,n=this.getSlotsInEpoch(t),s=e-(n-Ie);return[t,s]}else{const t=e-this.firstNormalSlot,n=Math.floor(t/this.slotsPerEpoch),s=this.firstNormalEpoch+n,r=t%this.slotsPerEpoch;return[s,r]}}getFirstSlotInEpoch(e){return e<=this.firstNormalEpoch?(Math.pow(2,e)-1)*Ie:(e-this.firstNormalEpoch)*this.slotsPerEpoch+this.firstNormalSlot}getLastSlotInEpoch(e){return this.getFirstSlotInEpoch(e)+this.getSlotsInEpoch(e)-1}getSlotsInEpoch(e){return e<this.firstNormalEpoch?Math.pow(2,e+Fe(Ie)):this.slotsPerEpoch}}var On=globalThis.fetch;class qn extends dn{constructor(e,t,n){const s=r=>{const o=hn(r,{autoconnect:!0,max_reconnects:5,reconnect:!0,reconnect_interval:1e3,...t});return"socket"in o?this.underlyingSocket=o.socket:this.underlyingSocket=o,o};super(s,e,t,n),this.underlyingSocket=void 0}call(...e){var n;const t=(n=this.underlyingSocket)==null?void 0:n.readyState;return t===1?super.call(...e):Promise.reject(new Error("Tried to call a JSON-RPC method `"+e[0]+"` but the socket was not `CONNECTING` or `OPEN` (`readyState` was "+t+")"))}notify(...e){var n;const t=(n=this.underlyingSocket)==null?void 0:n.readyState;return t===1?super.notify(...e):Promise.reject(new Error("Tried to send a JSON-RPC notification `"+e[0]+"` but the socket was not `CONNECTING` or `OPEN` (`readyState` was "+t+")"))}}function Fn(i,e){let t;try{t=i.layout.decode(e)}catch(n){throw new Error("invalid instruction; "+n)}if(t.typeIndex!==i.index)throw new Error(`invalid account data; account type mismatch ${t.typeIndex} != ${i.index}`);return t}const ft=56;class pt{constructor(e){this.key=void 0,this.state=void 0,this.key=e.key,this.state=e.state}isActive(){const e=BigInt("0xffffffffffffffff");return this.state.deactivationSlot===e}static deserialize(e){const t=Fn(Mn,e),n=e.length-ft;D(n>=0,"lookup table is invalid"),D(n%32===0,"lookup table is invalid");const s=n/32,{addresses:r}=w([G(L(),s,"addresses")]).decode(e.slice(ft));return{deactivationSlot:t.deactivationSlot,lastExtendedSlot:t.lastExtendedSlot,lastExtendedSlotStartIndex:t.lastExtendedStartIndex,authority:t.authority.length!==0?new B(t.authority[0]):void 0,addresses:r.map(o=>new B(o))}}}const Mn={index:1,layout:w([_("typeIndex"),me("deactivationSlot"),W("lastExtendedSlot"),N("lastExtendedStartIndex"),N(),G(L(),ae(N(),-1),"authority")])},Dn=/^[^:]+:\/\/([^:[]+|\[[^\]]+\])(:\d+)?(.*)/i;function Wn(i){const e=i.match(Dn);if(e==null)throw TypeError(`Failed to validate endpoint URL \`${i}\``);const[t,n,s,r]=e,o=i.startsWith("https:")?"wss:":"ws:",a=s==null?null:parseInt(s.slice(1),10),c=a==null?"":`:${a+1}`;return`${o}//${n}${c}${r}`}const q=Ee($e(B),h(),i=>new B(i)),Gt=Ve([h(),O("base64")]),st=Ee($e(v.Buffer),Gt,i=>v.Buffer.from(i[0],"base64")),zn=30*1e3;function Hn(i){if(/^https?:/.test(i)===!1)throw new TypeError("Endpoint URL must start with `http:` or `https:`.");return i}function K(i){let e,t;if(typeof i=="string")e=i;else if(i){const{commitment:n,...s}=i;e=n,t=s}return{commitment:e,config:t}}function gt(i){return i.map(e=>"memcmp"in e?{...e,memcmp:{...e.memcmp,encoding:e.memcmp.encoding??"base58"}}:e)}function jt(i){return j([d({jsonrpc:O("2.0"),id:h(),result:i}),d({jsonrpc:O("2.0"),id:h(),error:d({code:ye(),message:h(),data:A(un())})})])}const Gn=jt(ye());function x(i){return Ee(jt(i),Gn,e=>"error"in e?e:{...e,result:f(e.result,i)})}function M(i){return x(d({context:d({slot:u()}),value:i}))}function Ke(i){return d({context:d({slot:u()}),value:i})}function Me(i,e){return i===0?new Le({header:e.header,staticAccountKeys:e.accountKeys.map(t=>new B(t)),recentBlockhash:e.recentBlockhash,compiledInstructions:e.instructions.map(t=>({programIdIndex:t.programIdIndex,accountKeyIndexes:t.accounts,data:z.decode(t.data)})),addressTableLookups:e.addressTableLookups}):new ie(e)}const jn=d({foundation:u(),foundationTerm:u(),initial:u(),taper:u(),terminal:u()}),Vn=x(m(y(d({epoch:u(),effectiveSlot:u(),amount:u(),postBalance:u(),commission:A(y(u()))})))),$n=m(d({slot:u(),prioritizationFee:u()})),Jn=d({total:u(),validator:u(),foundation:u(),epoch:u()}),Xn=d({epoch:u(),slotIndex:u(),slotsInEpoch:u(),absoluteSlot:u(),blockHeight:A(u()),transactionCount:A(u())}),Zn=d({slotsPerEpoch:u(),leaderScheduleSlotOffset:u(),warmup:te(),firstNormalEpoch:u(),firstNormalSlot:u()}),Yn=St(h(),m(u())),ue=y(j([d({}),h()])),Qn=d({err:ue}),es=O("receivedSignature"),ts=d({"solana-core":h(),"feature-set":A(u())}),ns=d({program:h(),programId:q,parsed:ye()}),ss=d({programId:q,accounts:m(q),data:h()}),mt=M(d({err:y(j([d({}),h()])),logs:y(m(h())),accounts:A(y(m(y(d({executable:te(),owner:h(),lamports:u(),data:m(h()),rentEpoch:A(u())}))))),unitsConsumed:A(u()),returnData:A(y(d({programId:h(),data:Ve([h(),O("base64")])}))),innerInstructions:A(y(m(d({index:u(),instructions:m(j([ns,ss]))}))))})),rs=M(d({byIdentity:St(h(),m(u())),range:d({firstSlot:u(),lastSlot:u()})}));function os(i,e,t,n,s,r){const o=t||On;let a;r!=null&&console.warn("You have supplied an `httpAgent` when creating a `Connection` in a browser environment.It has been ignored; `httpAgent` is only used in Node environments.");let c;return n&&(c=async(R,E)=>{const T=await new Promise((k,b)=>{try{n(R,E,(p,I)=>k([p,I]))}catch(p){b(p)}});return await o(...T)}),new ln(async(R,E)=>{const T={method:"POST",body:R,agent:a,headers:Object.assign({"Content-Type":"application/json"},e||{},ir)};try{let k=5,b,p=500;for(;c?b=await c(i,T):b=await o(i,T),!(b.status!==429||s===!0||(k-=1,k===0));)console.error(`Server responded with ${b.status} ${b.statusText}.  Retrying after ${p}ms delay...`),await he(p),p*=2;const I=await b.text();b.ok?E(null,I):E(new Error(`${b.status} ${b.statusText}: ${I}`))}catch(k){k instanceof Error&&E(k)}},{})}function is(i){return(e,t)=>new Promise((n,s)=>{i.request(e,t,(r,o)=>{if(r){s(r);return}n(o)})})}function as(i){return e=>new Promise((t,n)=>{e.length===0&&t([]);const s=e.map(r=>i.request(r.methodName,r.args));i.request(s,(r,o)=>{if(r){n(r);return}t(o)})})}const cs=x(jn),us=x(Jn),ls=x($n),ds=x(Xn),hs=x(Zn),fs=x(Yn),ps=x(u()),gs=M(d({total:u(),circulating:u(),nonCirculating:u(),nonCirculatingAccounts:m(q)})),ze=d({amount:h(),uiAmount:y(u()),decimals:u(),uiAmountString:A(h())}),ms=M(m(d({address:q,amount:h(),uiAmount:y(u()),decimals:u(),uiAmountString:A(h())}))),ys=M(m(d({pubkey:q,account:d({executable:te(),owner:q,lamports:u(),data:st,rentEpoch:u()})}))),He=d({program:h(),parsed:ye(),space:u()}),bs=M(m(d({pubkey:q,account:d({executable:te(),owner:q,lamports:u(),data:He,rentEpoch:u()})}))),ws=M(m(d({lamports:u(),address:q}))),Re=d({executable:te(),owner:q,lamports:u(),data:st,rentEpoch:u()}),Ss=d({pubkey:q,account:Re}),ks=Ee(j([$e(v.Buffer),He]),j([Gt,He]),i=>Array.isArray(i)?f(i,st):i),Ge=d({executable:te(),owner:q,lamports:u(),data:ks,rentEpoch:u()}),Is=d({pubkey:q,account:Ge}),_s=d({state:j([O("active"),O("inactive"),O("activating"),O("deactivating")]),active:u(),inactive:u()}),As=x(m(d({signature:h(),slot:u(),err:ue,memo:y(h()),blockTime:A(y(u()))}))),Rs=x(m(d({signature:h(),slot:u(),err:ue,memo:y(h()),blockTime:A(y(u()))}))),Es=d({subscription:u(),result:Ke(Re)}),Bs=d({pubkey:q,account:Re}),xs=d({subscription:u(),result:Ke(Bs)}),vs=d({parent:u(),slot:u(),root:u()}),Ts=d({subscription:u(),result:vs}),Ls=j([d({type:j([O("firstShredReceived"),O("completed"),O("optimisticConfirmation"),O("root")]),slot:u(),timestamp:u()}),d({type:O("createdBank"),parent:u(),slot:u(),timestamp:u()}),d({type:O("frozen"),slot:u(),timestamp:u(),stats:d({numTransactionEntries:u(),numSuccessfulTransactions:u(),numFailedTransactions:u(),maxTransactionsPerEntry:u()})}),d({type:O("dead"),slot:u(),timestamp:u(),err:h()})]),Cs=d({subscription:u(),result:Ls}),Ps=d({subscription:u(),result:Ke(j([Qn,es]))}),Ns=d({subscription:u(),result:u()}),Us=d({pubkey:h(),gossip:y(h()),tpu:y(h()),rpc:y(h()),version:y(h())}),yt=d({votePubkey:h(),nodePubkey:h(),activatedStake:u(),epochVoteAccount:te(),epochCredits:m(Ve([u(),u(),u()])),commission:u(),lastVote:u(),rootSlot:y(u())}),Ks=x(d({current:m(yt),delinquent:m(yt)})),Os=j([O("processed"),O("confirmed"),O("finalized")]),qs=d({slot:u(),confirmations:y(u()),err:ue,confirmationStatus:A(Os)}),Fs=M(m(y(qs))),Ms=x(u()),Vt=d({accountKey:q,writableIndexes:m(u()),readonlyIndexes:m(u())}),rt=d({signatures:m(h()),message:d({accountKeys:m(h()),header:d({numRequiredSignatures:u(),numReadonlySignedAccounts:u(),numReadonlyUnsignedAccounts:u()}),instructions:m(d({accounts:m(u()),data:h(),programIdIndex:u()})),recentBlockhash:h(),addressTableLookups:A(m(Vt))})}),$t=d({pubkey:q,signer:te(),writable:te(),source:A(j([O("transaction"),O("lookupTable")]))}),Jt=d({accountKeys:m($t),signatures:m(h())}),Xt=d({parsed:ye(),program:h(),programId:q}),Zt=d({accounts:m(q),data:h(),programId:q}),Ds=j([Zt,Xt]),Ws=j([d({parsed:ye(),program:h(),programId:h()}),d({accounts:m(h()),data:h(),programId:h()})]),Yt=Ee(Ds,Ws,i=>"accounts"in i?f(i,Zt):f(i,Xt)),Qt=d({signatures:m(h()),message:d({accountKeys:m($t),instructions:m(Yt),recentBlockhash:h(),addressTableLookups:A(y(m(Vt)))})}),Ce=d({accountIndex:u(),mint:h(),owner:A(h()),uiTokenAmount:ze}),en=d({writable:m(q),readonly:m(q)}),Oe=d({err:ue,fee:u(),innerInstructions:A(y(m(d({index:u(),instructions:m(d({accounts:m(u()),data:h(),programIdIndex:u()}))})))),preBalances:m(u()),postBalances:m(u()),logMessages:A(y(m(h()))),preTokenBalances:A(y(m(Ce))),postTokenBalances:A(y(m(Ce))),loadedAddresses:A(en),computeUnitsConsumed:A(u())}),ot=d({err:ue,fee:u(),innerInstructions:A(y(m(d({index:u(),instructions:m(Yt)})))),preBalances:m(u()),postBalances:m(u()),logMessages:A(y(m(h()))),preTokenBalances:A(y(m(Ce))),postTokenBalances:A(y(m(Ce))),loadedAddresses:A(en),computeUnitsConsumed:A(u())}),Se=j([O(0),O("legacy")]),le=d({pubkey:h(),lamports:u(),postBalance:y(u()),rewardType:y(h()),commission:A(y(u()))}),zs=x(y(d({blockhash:h(),previousBlockhash:h(),parentSlot:u(),transactions:m(d({transaction:rt,meta:y(Oe),version:A(Se)})),rewards:A(m(le)),blockTime:y(u()),blockHeight:y(u())}))),Hs=x(y(d({blockhash:h(),previousBlockhash:h(),parentSlot:u(),rewards:A(m(le)),blockTime:y(u()),blockHeight:y(u())}))),Gs=x(y(d({blockhash:h(),previousBlockhash:h(),parentSlot:u(),transactions:m(d({transaction:Jt,meta:y(Oe),version:A(Se)})),rewards:A(m(le)),blockTime:y(u()),blockHeight:y(u())}))),js=x(y(d({blockhash:h(),previousBlockhash:h(),parentSlot:u(),transactions:m(d({transaction:Qt,meta:y(ot),version:A(Se)})),rewards:A(m(le)),blockTime:y(u()),blockHeight:y(u())}))),Vs=x(y(d({blockhash:h(),previousBlockhash:h(),parentSlot:u(),transactions:m(d({transaction:Jt,meta:y(ot),version:A(Se)})),rewards:A(m(le)),blockTime:y(u()),blockHeight:y(u())}))),$s=x(y(d({blockhash:h(),previousBlockhash:h(),parentSlot:u(),rewards:A(m(le)),blockTime:y(u()),blockHeight:y(u())}))),Js=x(y(d({blockhash:h(),previousBlockhash:h(),parentSlot:u(),transactions:m(d({transaction:rt,meta:y(Oe)})),rewards:A(m(le)),blockTime:y(u())}))),bt=x(y(d({blockhash:h(),previousBlockhash:h(),parentSlot:u(),signatures:m(h()),blockTime:y(u())}))),De=x(y(d({slot:u(),meta:y(Oe),blockTime:A(y(u())),transaction:rt,version:A(Se)}))),Be=x(y(d({slot:u(),transaction:Qt,meta:y(ot),blockTime:A(y(u())),version:A(Se)}))),Xs=M(d({blockhash:h(),feeCalculator:d({lamportsPerSignature:u()})})),Zs=M(d({blockhash:h(),lastValidBlockHeight:u()})),Ys=M(te()),Qs=d({slot:u(),numTransactions:u(),numSlots:u(),samplePeriodSecs:u()}),er=x(m(Qs)),tr=M(y(d({feeCalculator:d({lamportsPerSignature:u()})}))),nr=x(h()),sr=x(h()),rr=d({err:ue,logs:m(h()),signature:h()}),or=d({result:Ke(rr),subscription:u()}),ir={"solana-client":"js/1.0.0-maintenance"};class mr{constructor(e,t){this._commitment=void 0,this._confirmTransactionInitialTimeout=void 0,this._rpcEndpoint=void 0,this._rpcWsEndpoint=void 0,this._rpcClient=void 0,this._rpcRequest=void 0,this._rpcBatchRequest=void 0,this._rpcWebSocket=void 0,this._rpcWebSocketConnected=!1,this._rpcWebSocketHeartbeat=null,this._rpcWebSocketIdleTimeout=null,this._rpcWebSocketGeneration=0,this._disableBlockhashCaching=!1,this._pollingBlockhash=!1,this._blockhashInfo={latestBlockhash:null,lastFetch:0,transactionSignatures:[],simulatedSignatures:[]},this._nextClientSubscriptionId=0,this._subscriptionDisposeFunctionsByClientSubscriptionId={},this._subscriptionHashByClientSubscriptionId={},this._subscriptionStateChangeCallbacksByHash={},this._subscriptionCallbacksByServerSubscriptionId={},this._subscriptionsByHash={},this._subscriptionsAutoDisposedByRpc=new Set,this.getBlockHeight=(()=>{const g={};return async R=>{const{commitment:E,config:T}=K(R),k=this._buildArgs([],E,void 0,T),b=ht(k);return g[b]=g[b]??(async()=>{try{const p=await this._rpcRequest("getBlockHeight",k),I=f(p,x(u()));if("error"in I)throw new S(I.error,"failed to get block height information");return I.result}finally{delete g[b]}})(),await g[b]}})();let n,s,r,o,a,c;t&&typeof t=="string"?this._commitment=t:t&&(this._commitment=t.commitment,this._confirmTransactionInitialTimeout=t.confirmTransactionInitialTimeout,n=t.wsEndpoint,s=t.httpHeaders,r=t.fetch,o=t.fetchMiddleware,a=t.disableRetryOnRateLimit,c=t.httpAgent),this._rpcEndpoint=Hn(e),this._rpcWsEndpoint=n||Wn(e),this._rpcClient=os(e,s,r,o,a,c),this._rpcRequest=is(this._rpcClient),this._rpcBatchRequest=as(this._rpcClient),this._rpcWebSocket=new qn(this._rpcWsEndpoint,{autoconnect:!1,max_reconnects:1/0}),this._rpcWebSocket.on("open",this._wsOnOpen.bind(this)),this._rpcWebSocket.on("error",this._wsOnError.bind(this)),this._rpcWebSocket.on("close",this._wsOnClose.bind(this)),this._rpcWebSocket.on("accountNotification",this._wsOnAccountNotification.bind(this)),this._rpcWebSocket.on("programNotification",this._wsOnProgramAccountNotification.bind(this)),this._rpcWebSocket.on("slotNotification",this._wsOnSlotNotification.bind(this)),this._rpcWebSocket.on("slotsUpdatesNotification",this._wsOnSlotUpdatesNotification.bind(this)),this._rpcWebSocket.on("signatureNotification",this._wsOnSignatureNotification.bind(this)),this._rpcWebSocket.on("rootNotification",this._wsOnRootNotification.bind(this)),this._rpcWebSocket.on("logsNotification",this._wsOnLogsNotification.bind(this))}get commitment(){return this._commitment}get rpcEndpoint(){return this._rpcEndpoint}async getBalanceAndContext(e,t){const{commitment:n,config:s}=K(t),r=this._buildArgs([e.toBase58()],n,void 0,s),o=await this._rpcRequest("getBalance",r),a=f(o,M(u()));if("error"in a)throw new S(a.error,`failed to get balance for ${e.toBase58()}`);return a.result}async getBalance(e,t){return await this.getBalanceAndContext(e,t).then(n=>n.value).catch(n=>{throw new Error("failed to get balance of account "+e.toBase58()+": "+n)})}async getBlockTime(e){const t=await this._rpcRequest("getBlockTime",[e]),n=f(t,x(y(u())));if("error"in n)throw new S(n.error,`failed to get block time for slot ${e}`);return n.result}async getMinimumLedgerSlot(){const e=await this._rpcRequest("minimumLedgerSlot",[]),t=f(e,x(u()));if("error"in t)throw new S(t.error,"failed to get minimum ledger slot");return t.result}async getFirstAvailableBlock(){const e=await this._rpcRequest("getFirstAvailableBlock",[]),t=f(e,ps);if("error"in t)throw new S(t.error,"failed to get first available block");return t.result}async getSupply(e){let t={};typeof e=="string"?t={commitment:e}:e?t={...e,commitment:e&&e.commitment||this.commitment}:t={commitment:this.commitment};const n=await this._rpcRequest("getSupply",[t]),s=f(n,gs);if("error"in s)throw new S(s.error,"failed to get supply");return s.result}async getTokenSupply(e,t){const n=this._buildArgs([e.toBase58()],t),s=await this._rpcRequest("getTokenSupply",n),r=f(s,M(ze));if("error"in r)throw new S(r.error,"failed to get token supply");return r.result}async getTokenAccountBalance(e,t){const n=this._buildArgs([e.toBase58()],t),s=await this._rpcRequest("getTokenAccountBalance",n),r=f(s,M(ze));if("error"in r)throw new S(r.error,"failed to get token account balance");return r.result}async getTokenAccountsByOwner(e,t,n){const{commitment:s,config:r}=K(n);let o=[e.toBase58()];"mint"in t?o.push({mint:t.mint.toBase58()}):o.push({programId:t.programId.toBase58()});const a=this._buildArgs(o,s,"base64",r),c=await this._rpcRequest("getTokenAccountsByOwner",a),g=f(c,ys);if("error"in g)throw new S(g.error,`failed to get token accounts owned by account ${e.toBase58()}`);return g.result}async getParsedTokenAccountsByOwner(e,t,n){let s=[e.toBase58()];"mint"in t?s.push({mint:t.mint.toBase58()}):s.push({programId:t.programId.toBase58()});const r=this._buildArgs(s,n,"jsonParsed"),o=await this._rpcRequest("getTokenAccountsByOwner",r),a=f(o,bs);if("error"in a)throw new S(a.error,`failed to get token accounts owned by account ${e.toBase58()}`);return a.result}async getLargestAccounts(e){const t={...e,commitment:e&&e.commitment||this.commitment},n=t.filter||t.commitment?[t]:[],s=await this._rpcRequest("getLargestAccounts",n),r=f(s,ws);if("error"in r)throw new S(r.error,"failed to get largest accounts");return r.result}async getTokenLargestAccounts(e,t){const n=this._buildArgs([e.toBase58()],t),s=await this._rpcRequest("getTokenLargestAccounts",n),r=f(s,ms);if("error"in r)throw new S(r.error,"failed to get token largest accounts");return r.result}async getAccountInfoAndContext(e,t){const{commitment:n,config:s}=K(t),r=this._buildArgs([e.toBase58()],n,"base64",s),o=await this._rpcRequest("getAccountInfo",r),a=f(o,M(y(Re)));if("error"in a)throw new S(a.error,`failed to get info about account ${e.toBase58()}`);return a.result}async getParsedAccountInfo(e,t){const{commitment:n,config:s}=K(t),r=this._buildArgs([e.toBase58()],n,"jsonParsed",s),o=await this._rpcRequest("getAccountInfo",r),a=f(o,M(y(Ge)));if("error"in a)throw new S(a.error,`failed to get info about account ${e.toBase58()}`);return a.result}async getAccountInfo(e,t){try{return(await this.getAccountInfoAndContext(e,t)).value}catch(n){throw new Error("failed to get info about account "+e.toBase58()+": "+n)}}async getMultipleParsedAccounts(e,t){const{commitment:n,config:s}=K(t),r=e.map(g=>g.toBase58()),o=this._buildArgs([r],n,"jsonParsed",s),a=await this._rpcRequest("getMultipleAccounts",o),c=f(a,M(m(y(Ge))));if("error"in c)throw new S(c.error,`failed to get info for accounts ${r}`);return c.result}async getMultipleAccountsInfoAndContext(e,t){const{commitment:n,config:s}=K(t),r=e.map(g=>g.toBase58()),o=this._buildArgs([r],n,"base64",s),a=await this._rpcRequest("getMultipleAccounts",o),c=f(a,M(m(y(Re))));if("error"in c)throw new S(c.error,`failed to get info for accounts ${r}`);return c.result}async getMultipleAccountsInfo(e,t){return(await this.getMultipleAccountsInfoAndContext(e,t)).value}async getStakeActivation(e,t,n){const{commitment:s,config:r}=K(t),o=this._buildArgs([e.toBase58()],s,void 0,{...r,epoch:n??(r==null?void 0:r.epoch)}),a=await this._rpcRequest("getStakeActivation",o),c=f(a,x(_s));if("error"in c)throw new S(c.error,`failed to get Stake Activation ${e.toBase58()}`);return c.result}async getProgramAccounts(e,t){const{commitment:n,config:s}=K(t),{encoding:r,...o}=s||{},a=this._buildArgs([e.toBase58()],n,r||"base64",{...o,...o.filters?{filters:gt(o.filters)}:null}),c=await this._rpcRequest("getProgramAccounts",a),g=m(Ss),R=o.withContext===!0?f(c,M(g)):f(c,x(g));if("error"in R)throw new S(R.error,`failed to get accounts owned by program ${e.toBase58()}`);return R.result}async getParsedProgramAccounts(e,t){const{commitment:n,config:s}=K(t),r=this._buildArgs([e.toBase58()],n,"jsonParsed",s),o=await this._rpcRequest("getProgramAccounts",r),a=f(o,x(m(Is)));if("error"in a)throw new S(a.error,`failed to get accounts owned by program ${e.toBase58()}`);return a.result}async confirmTransaction(e,t){var r;let n;if(typeof e=="string")n=e;else{const o=e;if((r=o.abortSignal)!=null&&r.aborted)return Promise.reject(o.abortSignal.reason);n=o.signature}let s;try{s=z.decode(n)}catch{throw new Error("signature must be base58 encoded: "+n)}return D(s.length===64,"signature has invalid length"),typeof e=="string"?await this.confirmTransactionUsingLegacyTimeoutStrategy({commitment:t||this.commitment,signature:n}):"lastValidBlockHeight"in e?await this.confirmTransactionUsingBlockHeightExceedanceStrategy({commitment:t||this.commitment,strategy:e}):await this.confirmTransactionUsingDurableNonceStrategy({commitment:t||this.commitment,strategy:e})}getCancellationPromise(e){return new Promise((t,n)=>{e!=null&&(e.aborted?n(e.reason):e.addEventListener("abort",()=>{n(e.reason)}))})}getTransactionConfirmationPromise({commitment:e,signature:t}){let n,s,r=!1;const o=new Promise((c,g)=>{try{n=this.onSignature(t,(E,T)=>{n=void 0;const k={context:T,value:E};c({__type:se.PROCESSED,response:k})},e);const R=new Promise(E=>{n==null?E():s=this._onSubscriptionStateChange(n,T=>{T==="subscribed"&&E()})});(async()=>{if(await R,r)return;const E=await this.getSignatureStatus(t);if(r||E==null)return;const{context:T,value:k}=E;if(k!=null)if(k!=null&&k.err)g(k.err);else{switch(e){case"confirmed":case"single":case"singleGossip":{if(k.confirmationStatus==="processed")return;break}case"finalized":case"max":case"root":{if(k.confirmationStatus==="processed"||k.confirmationStatus==="confirmed")return;break}case"processed":case"recent":}r=!0,c({__type:se.PROCESSED,response:{context:T,value:k}})}})()}catch(R){g(R)}});return{abortConfirmation:()=>{s&&(s(),s=void 0),n!=null&&(this.removeSignatureListener(n),n=void 0)},confirmationPromise:o}}async confirmTransactionUsingBlockHeightExceedanceStrategy({commitment:e,strategy:{abortSignal:t,lastValidBlockHeight:n,signature:s}}){let r=!1;const o=new Promise(E=>{const T=async()=>{try{return await this.getBlockHeight(e)}catch{return-1}};(async()=>{let k=await T();if(!r){for(;k<=n;)if(await he(1e3),r||(k=await T(),r))return;E({__type:se.BLOCKHEIGHT_EXCEEDED})}})()}),{abortConfirmation:a,confirmationPromise:c}=this.getTransactionConfirmationPromise({commitment:e,signature:s}),g=this.getCancellationPromise(t);let R;try{const E=await Promise.race([g,c,o]);if(E.__type===se.PROCESSED)R=E.response;else throw new Dt(s)}finally{r=!0,a()}return R}async confirmTransactionUsingDurableNonceStrategy({commitment:e,strategy:{abortSignal:t,minContextSlot:n,nonceAccountPubkey:s,nonceValue:r,signature:o}}){let a=!1;const c=new Promise(k=>{let b=r,p=null;const I=async()=>{try{const{context:C,value:H}=await this.getNonceAndContext(s,{commitment:e,minContextSlot:n});return p=C.slot,H==null?void 0:H.nonce}catch{return b}};(async()=>{if(b=await I(),!a)for(;;){if(r!==b){k({__type:se.NONCE_INVALID,slotInWhichNonceDidAdvance:p});return}if(await he(2e3),a||(b=await I(),a))return}})()}),{abortConfirmation:g,confirmationPromise:R}=this.getTransactionConfirmationPromise({commitment:e,signature:o}),E=this.getCancellationPromise(t);let T;try{const k=await Promise.race([E,R,c]);if(k.__type===se.PROCESSED)T=k.response;else{let b;for(;;){const p=await this.getSignatureStatus(o);if(p==null)break;if(p.context.slot<(k.slotInWhichNonceDidAdvance??n)){await he(400);continue}b=p;break}if(b!=null&&b.value){const p=e||"finalized",{confirmationStatus:I}=b.value;switch(p){case"processed":case"recent":if(I!=="processed"&&I!=="confirmed"&&I!=="finalized")throw new _e(o);break;case"confirmed":case"single":case"singleGossip":if(I!=="confirmed"&&I!=="finalized")throw new _e(o);break;case"finalized":case"max":case"root":if(I!=="finalized")throw new _e(o);break;default:}T={context:b.context,value:{err:b.value.err}}}else throw new _e(o)}}finally{a=!0,g()}return T}async confirmTransactionUsingLegacyTimeoutStrategy({commitment:e,signature:t}){let n;const s=new Promise(c=>{let g=this._confirmTransactionInitialTimeout||6e4;switch(e){case"processed":case"recent":case"single":case"confirmed":case"singleGossip":{g=this._confirmTransactionInitialTimeout||3e4;break}}n=setTimeout(()=>c({__type:se.TIMED_OUT,timeoutMs:g}),g)}),{abortConfirmation:r,confirmationPromise:o}=this.getTransactionConfirmationPromise({commitment:e,signature:t});let a;try{const c=await Promise.race([o,s]);if(c.__type===se.PROCESSED)a=c.response;else throw new Wt(t,c.timeoutMs/1e3)}finally{clearTimeout(n),r()}return a}async getClusterNodes(){const e=await this._rpcRequest("getClusterNodes",[]),t=f(e,x(m(Us)));if("error"in t)throw new S(t.error,"failed to get cluster nodes");return t.result}async getVoteAccounts(e){const t=this._buildArgs([],e),n=await this._rpcRequest("getVoteAccounts",t),s=f(n,Ks);if("error"in s)throw new S(s.error,"failed to get vote accounts");return s.result}async getSlot(e){const{commitment:t,config:n}=K(e),s=this._buildArgs([],t,void 0,n),r=await this._rpcRequest("getSlot",s),o=f(r,x(u()));if("error"in o)throw new S(o.error,"failed to get slot");return o.result}async getSlotLeader(e){const{commitment:t,config:n}=K(e),s=this._buildArgs([],t,void 0,n),r=await this._rpcRequest("getSlotLeader",s),o=f(r,x(h()));if("error"in o)throw new S(o.error,"failed to get slot leader");return o.result}async getSlotLeaders(e,t){const n=[e,t],s=await this._rpcRequest("getSlotLeaders",n),r=f(s,x(m(q)));if("error"in r)throw new S(r.error,"failed to get slot leaders");return r.result}async getSignatureStatus(e,t){const{context:n,value:s}=await this.getSignatureStatuses([e],t);D(s.length===1);const r=s[0];return{context:n,value:r}}async getSignatureStatuses(e,t){const n=[e];t&&n.push(t);const s=await this._rpcRequest("getSignatureStatuses",n),r=f(s,Fs);if("error"in r)throw new S(r.error,"failed to get signature status");return r.result}async getTransactionCount(e){const{commitment:t,config:n}=K(e),s=this._buildArgs([],t,void 0,n),r=await this._rpcRequest("getTransactionCount",s),o=f(r,x(u()));if("error"in o)throw new S(o.error,"failed to get transaction count");return o.result}async getTotalSupply(e){return(await this.getSupply({commitment:e,excludeNonCirculatingAccountsList:!0})).value.total}async getInflationGovernor(e){const t=this._buildArgs([],e),n=await this._rpcRequest("getInflationGovernor",t),s=f(n,cs);if("error"in s)throw new S(s.error,"failed to get inflation");return s.result}async getInflationReward(e,t,n){const{commitment:s,config:r}=K(n),o=this._buildArgs([e.map(g=>g.toBase58())],s,void 0,{...r,epoch:t??(r==null?void 0:r.epoch)}),a=await this._rpcRequest("getInflationReward",o),c=f(a,Vn);if("error"in c)throw new S(c.error,"failed to get inflation reward");return c.result}async getInflationRate(){const e=await this._rpcRequest("getInflationRate",[]),t=f(e,us);if("error"in t)throw new S(t.error,"failed to get inflation rate");return t.result}async getEpochInfo(e){const{commitment:t,config:n}=K(e),s=this._buildArgs([],t,void 0,n),r=await this._rpcRequest("getEpochInfo",s),o=f(r,ds);if("error"in o)throw new S(o.error,"failed to get epoch info");return o.result}async getEpochSchedule(){const e=await this._rpcRequest("getEpochSchedule",[]),t=f(e,hs);if("error"in t)throw new S(t.error,"failed to get epoch schedule");const n=t.result;return new Kn(n.slotsPerEpoch,n.leaderScheduleSlotOffset,n.warmup,n.firstNormalEpoch,n.firstNormalSlot)}async getLeaderSchedule(){const e=await this._rpcRequest("getLeaderSchedule",[]),t=f(e,fs);if("error"in t)throw new S(t.error,"failed to get leader schedule");return t.result}async getMinimumBalanceForRentExemption(e,t){const n=this._buildArgs([e],t),s=await this._rpcRequest("getMinimumBalanceForRentExemption",n),r=f(s,Ms);return"error"in r?(console.warn("Unable to fetch minimum balance for rent exemption"),0):r.result}async getRecentBlockhashAndContext(e){const t=this._buildArgs([],e),n=await this._rpcRequest("getRecentBlockhash",t),s=f(n,Xs);if("error"in s)throw new S(s.error,"failed to get recent blockhash");return s.result}async getRecentPerformanceSamples(e){const t=await this._rpcRequest("getRecentPerformanceSamples",e?[e]:[]),n=f(t,er);if("error"in n)throw new S(n.error,"failed to get recent performance samples");return n.result}async getFeeCalculatorForBlockhash(e,t){const n=this._buildArgs([e],t),s=await this._rpcRequest("getFeeCalculatorForBlockhash",n),r=f(s,tr);if("error"in r)throw new S(r.error,"failed to get fee calculator");const{context:o,value:a}=r.result;return{context:o,value:a!==null?a.feeCalculator:null}}async getFeeForMessage(e,t){const n=ge(e.serialize()).toString("base64"),s=this._buildArgs([n],t),r=await this._rpcRequest("getFeeForMessage",s),o=f(r,M(y(u())));if("error"in o)throw new S(o.error,"failed to get fee for message");if(o.result===null)throw new Error("invalid blockhash");return o.result}async getRecentPrioritizationFees(e){var o;const t=(o=e==null?void 0:e.lockedWritableAccounts)==null?void 0:o.map(a=>a.toBase58()),n=t!=null&&t.length?[t]:[],s=await this._rpcRequest("getRecentPrioritizationFees",n),r=f(s,ls);if("error"in r)throw new S(r.error,"failed to get recent prioritization fees");return r.result}async getRecentBlockhash(e){try{return(await this.getRecentBlockhashAndContext(e)).value}catch(t){throw new Error("failed to get recent blockhash: "+t)}}async getLatestBlockhash(e){try{return(await this.getLatestBlockhashAndContext(e)).value}catch(t){throw new Error("failed to get recent blockhash: "+t)}}async getLatestBlockhashAndContext(e){const{commitment:t,config:n}=K(e),s=this._buildArgs([],t,void 0,n),r=await this._rpcRequest("getLatestBlockhash",s),o=f(r,Zs);if("error"in o)throw new S(o.error,"failed to get latest blockhash");return o.result}async isBlockhashValid(e,t){const{commitment:n,config:s}=K(t),r=this._buildArgs([e],n,void 0,s),o=await this._rpcRequest("isBlockhashValid",r),a=f(o,Ys);if("error"in a)throw new S(a.error,"failed to determine if the blockhash `"+e+"`is valid");return a.result}async getVersion(){const e=await this._rpcRequest("getVersion",[]),t=f(e,x(ts));if("error"in t)throw new S(t.error,"failed to get version");return t.result}async getGenesisHash(){const e=await this._rpcRequest("getGenesisHash",[]),t=f(e,x(h()));if("error"in t)throw new S(t.error,"failed to get genesis hash");return t.result}async getBlock(e,t){const{commitment:n,config:s}=K(t),r=this._buildArgsAtLeastConfirmed([e],n,void 0,s),o=await this._rpcRequest("getBlock",r);try{switch(s==null?void 0:s.transactionDetails){case"accounts":{const a=f(o,Gs);if("error"in a)throw a.error;return a.result}case"none":{const a=f(o,Hs);if("error"in a)throw a.error;return a.result}default:{const a=f(o,zs);if("error"in a)throw a.error;const{result:c}=a;return c?{...c,transactions:c.transactions.map(({transaction:g,meta:R,version:E})=>({meta:R,transaction:{...g,message:Me(E,g.message)},version:E}))}:null}}}catch(a){throw new S(a,"failed to get confirmed block")}}async getParsedBlock(e,t){const{commitment:n,config:s}=K(t),r=this._buildArgsAtLeastConfirmed([e],n,"jsonParsed",s),o=await this._rpcRequest("getBlock",r);try{switch(s==null?void 0:s.transactionDetails){case"accounts":{const a=f(o,Vs);if("error"in a)throw a.error;return a.result}case"none":{const a=f(o,$s);if("error"in a)throw a.error;return a.result}default:{const a=f(o,js);if("error"in a)throw a.error;return a.result}}}catch(a){throw new S(a,"failed to get block")}}async getBlockProduction(e){let t,n;if(typeof e=="string")n=e;else if(e){const{commitment:a,...c}=e;n=a,t=c}const s=this._buildArgs([],n,"base64",t),r=await this._rpcRequest("getBlockProduction",s),o=f(r,rs);if("error"in o)throw new S(o.error,"failed to get block production information");return o.result}async getTransaction(e,t){const{commitment:n,config:s}=K(t),r=this._buildArgsAtLeastConfirmed([e],n,void 0,s),o=await this._rpcRequest("getTransaction",r),a=f(o,De);if("error"in a)throw new S(a.error,"failed to get transaction");const c=a.result;return c&&{...c,transaction:{...c.transaction,message:Me(c.version,c.transaction.message)}}}async getParsedTransaction(e,t){const{commitment:n,config:s}=K(t),r=this._buildArgsAtLeastConfirmed([e],n,"jsonParsed",s),o=await this._rpcRequest("getTransaction",r),a=f(o,Be);if("error"in a)throw new S(a.error,"failed to get transaction");return a.result}async getParsedTransactions(e,t){const{commitment:n,config:s}=K(t),r=e.map(c=>({methodName:"getTransaction",args:this._buildArgsAtLeastConfirmed([c],n,"jsonParsed",s)}));return(await this._rpcBatchRequest(r)).map(c=>{const g=f(c,Be);if("error"in g)throw new S(g.error,"failed to get transactions");return g.result})}async getTransactions(e,t){const{commitment:n,config:s}=K(t),r=e.map(c=>({methodName:"getTransaction",args:this._buildArgsAtLeastConfirmed([c],n,void 0,s)}));return(await this._rpcBatchRequest(r)).map(c=>{const g=f(c,De);if("error"in g)throw new S(g.error,"failed to get transactions");const R=g.result;return R&&{...R,transaction:{...R.transaction,message:Me(R.version,R.transaction.message)}}})}async getConfirmedBlock(e,t){const n=this._buildArgsAtLeastConfirmed([e],t),s=await this._rpcRequest("getConfirmedBlock",n),r=f(s,Js);if("error"in r)throw new S(r.error,"failed to get confirmed block");const o=r.result;if(!o)throw new Error("Confirmed block "+e+" not found");const a={...o,transactions:o.transactions.map(({transaction:c,meta:g})=>{const R=new ie(c.message);return{meta:g,transaction:{...c,message:R}}})};return{...a,transactions:a.transactions.map(({transaction:c,meta:g})=>({meta:g,transaction:re.populate(c.message,c.signatures)}))}}async getBlocks(e,t,n){const s=this._buildArgsAtLeastConfirmed(t!==void 0?[e,t]:[e],n),r=await this._rpcRequest("getBlocks",s),o=f(r,x(m(u())));if("error"in o)throw new S(o.error,"failed to get blocks");return o.result}async getBlockSignatures(e,t){const n=this._buildArgsAtLeastConfirmed([e],t,void 0,{transactionDetails:"signatures",rewards:!1}),s=await this._rpcRequest("getBlock",n),r=f(s,bt);if("error"in r)throw new S(r.error,"failed to get block");const o=r.result;if(!o)throw new Error("Block "+e+" not found");return o}async getConfirmedBlockSignatures(e,t){const n=this._buildArgsAtLeastConfirmed([e],t,void 0,{transactionDetails:"signatures",rewards:!1}),s=await this._rpcRequest("getConfirmedBlock",n),r=f(s,bt);if("error"in r)throw new S(r.error,"failed to get confirmed block");const o=r.result;if(!o)throw new Error("Confirmed block "+e+" not found");return o}async getConfirmedTransaction(e,t){const n=this._buildArgsAtLeastConfirmed([e],t),s=await this._rpcRequest("getConfirmedTransaction",n),r=f(s,De);if("error"in r)throw new S(r.error,"failed to get transaction");const o=r.result;if(!o)return o;const a=new ie(o.transaction.message),c=o.transaction.signatures;return{...o,transaction:re.populate(a,c)}}async getParsedConfirmedTransaction(e,t){const n=this._buildArgsAtLeastConfirmed([e],t,"jsonParsed"),s=await this._rpcRequest("getConfirmedTransaction",n),r=f(s,Be);if("error"in r)throw new S(r.error,"failed to get confirmed transaction");return r.result}async getParsedConfirmedTransactions(e,t){const n=e.map(o=>({methodName:"getConfirmedTransaction",args:this._buildArgsAtLeastConfirmed([o],t,"jsonParsed")}));return(await this._rpcBatchRequest(n)).map(o=>{const a=f(o,Be);if("error"in a)throw new S(a.error,"failed to get confirmed transactions");return a.result})}async getConfirmedSignaturesForAddress(e,t,n){let s={},r=await this.getFirstAvailableBlock();for(;!("until"in s)&&(t--,!(t<=0||t<r));)try{const c=await this.getConfirmedBlockSignatures(t,"finalized");c.signatures.length>0&&(s.until=c.signatures[c.signatures.length-1].toString())}catch(c){if(c instanceof Error&&c.message.includes("skipped"))continue;throw c}let o=await this.getSlot("finalized");for(;!("before"in s)&&(n++,!(n>o));)try{const c=await this.getConfirmedBlockSignatures(n);c.signatures.length>0&&(s.before=c.signatures[c.signatures.length-1].toString())}catch(c){if(c instanceof Error&&c.message.includes("skipped"))continue;throw c}return(await this.getConfirmedSignaturesForAddress2(e,s)).map(c=>c.signature)}async getConfirmedSignaturesForAddress2(e,t,n){const s=this._buildArgsAtLeastConfirmed([e.toBase58()],n,void 0,t),r=await this._rpcRequest("getConfirmedSignaturesForAddress2",s),o=f(r,As);if("error"in o)throw new S(o.error,"failed to get confirmed signatures for address");return o.result}async getSignaturesForAddress(e,t,n){const s=this._buildArgsAtLeastConfirmed([e.toBase58()],n,void 0,t),r=await this._rpcRequest("getSignaturesForAddress",s),o=f(r,Rs);if("error"in o)throw new S(o.error,"failed to get signatures for address");return o.result}async getAddressLookupTable(e,t){const{context:n,value:s}=await this.getAccountInfoAndContext(e,t);let r=null;return s!==null&&(r=new pt({key:e,state:pt.deserialize(s.data)})),{context:n,value:r}}async getNonceAndContext(e,t){const{context:n,value:s}=await this.getAccountInfoAndContext(e,t);let r=null;return s!==null&&(r=nt.fromAccountData(s.data)),{context:n,value:r}}async getNonce(e,t){return await this.getNonceAndContext(e,t).then(n=>n.value).catch(n=>{throw new Error("failed to get nonce for account "+e.toBase58()+": "+n)})}async requestAirdrop(e,t){const n=await this._rpcRequest("requestAirdrop",[e.toBase58(),t]),s=f(n,nr);if("error"in s)throw new S(s.error,`airdrop to ${e.toBase58()} failed`);return s.result}async _blockhashWithExpiryBlockHeight(e){if(!e){for(;this._pollingBlockhash;)await he(100);const n=Date.now()-this._blockhashInfo.lastFetch>=zn;if(this._blockhashInfo.latestBlockhash!==null&&!n)return this._blockhashInfo.latestBlockhash}return await this._pollNewBlockhash()}async _pollNewBlockhash(){this._pollingBlockhash=!0;try{const e=Date.now(),t=this._blockhashInfo.latestBlockhash,n=t?t.blockhash:null;for(let s=0;s<50;s++){const r=await this.getLatestBlockhash("finalized");if(n!==r.blockhash)return this._blockhashInfo={latestBlockhash:r,lastFetch:Date.now(),transactionSignatures:[],simulatedSignatures:[]},r;await he(Bn/2)}throw new Error(`Unable to obtain a new blockhash after ${Date.now()-e}ms`)}finally{this._pollingBlockhash=!1}}async getStakeMinimumDelegation(e){const{commitment:t,config:n}=K(e),s=this._buildArgs([],t,"base64",n),r=await this._rpcRequest("getStakeMinimumDelegation",s),o=f(r,M(u()));if("error"in o)throw new S(o.error,"failed to get stake minimum delegation");return o.result}async simulateTransaction(e,t,n){if("message"in e){const p=e.serialize(),I=v.Buffer.from(p).toString("base64");if(Array.isArray(t)||n!==void 0)throw new Error("Invalid arguments");const C=t||{};C.encoding="base64","commitment"in C||(C.commitment=this.commitment),t&&typeof t=="object"&&"innerInstructions"in t&&(C.innerInstructions=t.innerInstructions);const H=[I,C],ke=await this._rpcRequest("simulateTransaction",H),qe=f(ke,mt);if("error"in qe)throw new Error("failed to simulate transaction: "+qe.error.message);return qe.result}let s;if(e instanceof re){let b=e;s=new re,s.feePayer=b.feePayer,s.instructions=e.instructions,s.nonceInfo=b.nonceInfo,s.signatures=b.signatures}else s=re.populate(e),s._message=s._json=void 0;if(t!==void 0&&!Array.isArray(t))throw new Error("Invalid arguments");const r=t;if(s.nonceInfo&&r)s.sign(...r);else{let b=this._disableBlockhashCaching;for(;;){const p=await this._blockhashWithExpiryBlockHeight(b);if(s.lastValidBlockHeight=p.lastValidBlockHeight,s.recentBlockhash=p.blockhash,!r)break;if(s.sign(...r),!s.signature)throw new Error("!signature");const I=s.signature.toString("base64");if(!this._blockhashInfo.simulatedSignatures.includes(I)&&!this._blockhashInfo.transactionSignatures.includes(I)){this._blockhashInfo.simulatedSignatures.push(I);break}else b=!0}}const o=s._compile(),a=o.serialize(),g=s._serialize(a).toString("base64"),R={encoding:"base64",commitment:this.commitment};if(n){const b=(Array.isArray(n)?n:o.nonProgramIds()).map(p=>p.toBase58());R.accounts={encoding:"base64",addresses:b}}r&&(R.sigVerify=!0),t&&typeof t=="object"&&"innerInstructions"in t&&(R.innerInstructions=t.innerInstructions);const E=[g,R],T=await this._rpcRequest("simulateTransaction",E),k=f(T,mt);if("error"in k){let b;if("data"in k.error&&(b=k.error.data.logs,b&&Array.isArray(b))){const p=`
    `,I=p+b.join(p);console.error(k.error.message,I)}throw new dt({action:"simulate",signature:"",transactionMessage:k.error.message,logs:b})}return k.result}async sendTransaction(e,t,n){if("version"in e){if(t&&Array.isArray(t))throw new Error("Invalid arguments");const o=e.serialize();return await this.sendRawTransaction(o,t)}if(t===void 0||!Array.isArray(t))throw new Error("Invalid arguments");const s=t;if(e.nonceInfo)e.sign(...s);else{let o=this._disableBlockhashCaching;for(;;){const a=await this._blockhashWithExpiryBlockHeight(o);if(e.lastValidBlockHeight=a.lastValidBlockHeight,e.recentBlockhash=a.blockhash,e.sign(...s),!e.signature)throw new Error("!signature");const c=e.signature.toString("base64");if(this._blockhashInfo.transactionSignatures.includes(c))o=!0;else{this._blockhashInfo.transactionSignatures.push(c);break}}}const r=e.serialize();return await this.sendRawTransaction(r,n)}async sendRawTransaction(e,t){const n=ge(e).toString("base64");return await this.sendEncodedTransaction(n,t)}async sendEncodedTransaction(e,t){const n={encoding:"base64"},s=t&&t.skipPreflight,r=s===!0?"processed":t&&t.preflightCommitment||this.commitment;t&&t.maxRetries!=null&&(n.maxRetries=t.maxRetries),t&&t.minContextSlot!=null&&(n.minContextSlot=t.minContextSlot),s&&(n.skipPreflight=s),r&&(n.preflightCommitment=r);const o=[e,n],a=await this._rpcRequest("sendTransaction",o),c=f(a,sr);if("error"in c){let g;throw"data"in c.error&&(g=c.error.data.logs),new dt({action:s?"send":"simulate",signature:"",transactionMessage:c.error.message,logs:g})}return c.result}_wsOnOpen(){this._rpcWebSocketConnected=!0,this._rpcWebSocketHeartbeat=setInterval(()=>{(async()=>{try{await this._rpcWebSocket.notify("ping")}catch{}})()},5e3),this._updateSubscriptions()}_wsOnError(e){this._rpcWebSocketConnected=!1,console.error("ws error:",e.message)}_wsOnClose(e){if(this._rpcWebSocketConnected=!1,this._rpcWebSocketGeneration=(this._rpcWebSocketGeneration+1)%Number.MAX_SAFE_INTEGER,this._rpcWebSocketIdleTimeout&&(clearTimeout(this._rpcWebSocketIdleTimeout),this._rpcWebSocketIdleTimeout=null),this._rpcWebSocketHeartbeat&&(clearInterval(this._rpcWebSocketHeartbeat),this._rpcWebSocketHeartbeat=null),e===1e3){this._updateSubscriptions();return}this._subscriptionCallbacksByServerSubscriptionId={},Object.entries(this._subscriptionsByHash).forEach(([t,n])=>{this._setSubscription(t,{...n,state:"pending"})})}_setSubscription(e,t){var s;const n=(s=this._subscriptionsByHash[e])==null?void 0:s.state;if(this._subscriptionsByHash[e]=t,n!==t.state){const r=this._subscriptionStateChangeCallbacksByHash[e];r&&r.forEach(o=>{try{o(t.state)}catch{}})}}_onSubscriptionStateChange(e,t){var r;const n=this._subscriptionHashByClientSubscriptionId[e];if(n==null)return()=>{};const s=(r=this._subscriptionStateChangeCallbacksByHash)[n]||(r[n]=new Set);return s.add(t),()=>{s.delete(t),s.size===0&&delete this._subscriptionStateChangeCallbacksByHash[n]}}async _updateSubscriptions(){if(Object.keys(this._subscriptionsByHash).length===0){this._rpcWebSocketConnected&&(this._rpcWebSocketConnected=!1,this._rpcWebSocketIdleTimeout=setTimeout(()=>{this._rpcWebSocketIdleTimeout=null;try{this._rpcWebSocket.close()}catch(n){n instanceof Error&&console.log(`Error when closing socket connection: ${n.message}`)}},500));return}if(this._rpcWebSocketIdleTimeout!==null&&(clearTimeout(this._rpcWebSocketIdleTimeout),this._rpcWebSocketIdleTimeout=null,this._rpcWebSocketConnected=!0),!this._rpcWebSocketConnected){this._rpcWebSocket.connect();return}const e=this._rpcWebSocketGeneration,t=()=>e===this._rpcWebSocketGeneration;await Promise.all(Object.keys(this._subscriptionsByHash).map(async n=>{const s=this._subscriptionsByHash[n];if(s!==void 0)switch(s.state){case"pending":case"unsubscribed":if(s.callbacks.size===0){delete this._subscriptionsByHash[n],s.state==="unsubscribed"&&delete this._subscriptionCallbacksByServerSubscriptionId[s.serverSubscriptionId],await this._updateSubscriptions();return}await(async()=>{const{args:r,method:o}=s;try{this._setSubscription(n,{...s,state:"subscribing"});const a=await this._rpcWebSocket.call(o,r);this._setSubscription(n,{...s,serverSubscriptionId:a,state:"subscribed"}),this._subscriptionCallbacksByServerSubscriptionId[a]=s.callbacks,await this._updateSubscriptions()}catch(a){if(a instanceof Error&&console.error(`${o} error for argument`,r,a.message),!t())return;this._setSubscription(n,{...s,state:"pending"}),await this._updateSubscriptions()}})();break;case"subscribed":s.callbacks.size===0&&await(async()=>{const{serverSubscriptionId:r,unsubscribeMethod:o}=s;if(this._subscriptionsAutoDisposedByRpc.has(r))this._subscriptionsAutoDisposedByRpc.delete(r);else{this._setSubscription(n,{...s,state:"unsubscribing"}),this._setSubscription(n,{...s,state:"unsubscribing"});try{await this._rpcWebSocket.call(o,[r])}catch(a){if(a instanceof Error&&console.error(`${o} error:`,a.message),!t())return;this._setSubscription(n,{...s,state:"subscribed"}),await this._updateSubscriptions();return}}this._setSubscription(n,{...s,state:"unsubscribed"}),await this._updateSubscriptions()})();break}}))}_handleServerNotification(e,t){const n=this._subscriptionCallbacksByServerSubscriptionId[e];n!==void 0&&n.forEach(s=>{try{s(...t)}catch(r){console.error(r)}})}_wsOnAccountNotification(e){const{result:t,subscription:n}=f(e,Es);this._handleServerNotification(n,[t.value,t.context])}_makeSubscription(e,t){const n=this._nextClientSubscriptionId++,s=ht([e.method,t]),r=this._subscriptionsByHash[s];return r===void 0?this._subscriptionsByHash[s]={...e,args:t,callbacks:new Set([e.callback]),state:"pending"}:r.callbacks.add(e.callback),this._subscriptionHashByClientSubscriptionId[n]=s,this._subscriptionDisposeFunctionsByClientSubscriptionId[n]=async()=>{delete this._subscriptionDisposeFunctionsByClientSubscriptionId[n],delete this._subscriptionHashByClientSubscriptionId[n];const o=this._subscriptionsByHash[s];D(o!==void 0,`Could not find a \`Subscription\` when tearing down client subscription #${n}`),o.callbacks.delete(e.callback),await this._updateSubscriptions()},this._updateSubscriptions(),n}onAccountChange(e,t,n){const{commitment:s,config:r}=K(n),o=this._buildArgs([e.toBase58()],s||this._commitment||"finalized","base64",r);return this._makeSubscription({callback:t,method:"accountSubscribe",unsubscribeMethod:"accountUnsubscribe"},o)}async removeAccountChangeListener(e){await this._unsubscribeClientSubscription(e,"account change")}_wsOnProgramAccountNotification(e){const{result:t,subscription:n}=f(e,xs);this._handleServerNotification(n,[{accountId:t.value.pubkey,accountInfo:t.value.account},t.context])}onProgramAccountChange(e,t,n,s){const{commitment:r,config:o}=K(n),a=this._buildArgs([e.toBase58()],r||this._commitment||"finalized","base64",o||(s?{filters:gt(s)}:void 0));return this._makeSubscription({callback:t,method:"programSubscribe",unsubscribeMethod:"programUnsubscribe"},a)}async removeProgramAccountChangeListener(e){await this._unsubscribeClientSubscription(e,"program account change")}onLogs(e,t,n){const s=this._buildArgs([typeof e=="object"?{mentions:[e.toString()]}:e],n||this._commitment||"finalized");return this._makeSubscription({callback:t,method:"logsSubscribe",unsubscribeMethod:"logsUnsubscribe"},s)}async removeOnLogsListener(e){await this._unsubscribeClientSubscription(e,"logs")}_wsOnLogsNotification(e){const{result:t,subscription:n}=f(e,or);this._handleServerNotification(n,[t.value,t.context])}_wsOnSlotNotification(e){const{result:t,subscription:n}=f(e,Ts);this._handleServerNotification(n,[t])}onSlotChange(e){return this._makeSubscription({callback:e,method:"slotSubscribe",unsubscribeMethod:"slotUnsubscribe"},[])}async removeSlotChangeListener(e){await this._unsubscribeClientSubscription(e,"slot change")}_wsOnSlotUpdatesNotification(e){const{result:t,subscription:n}=f(e,Cs);this._handleServerNotification(n,[t])}onSlotUpdate(e){return this._makeSubscription({callback:e,method:"slotsUpdatesSubscribe",unsubscribeMethod:"slotsUpdatesUnsubscribe"},[])}async removeSlotUpdateListener(e){await this._unsubscribeClientSubscription(e,"slot update")}async _unsubscribeClientSubscription(e,t){const n=this._subscriptionDisposeFunctionsByClientSubscriptionId[e];n?await n():console.warn(`Ignored unsubscribe request because an active subscription with id \`${e}\` for '${t}' events could not be found.`)}_buildArgs(e,t,n,s){const r=t||this._commitment;if(r||n||s){let o={};n&&(o.encoding=n),r&&(o.commitment=r),s&&(o=Object.assign(o,s)),e.push(o)}return e}_buildArgsAtLeastConfirmed(e,t,n,s){const r=t||this._commitment;if(r&&!["confirmed","finalized"].includes(r))throw new Error("Using Connection with default commitment: `"+this._commitment+"`, but method requires at least `confirmed`");return this._buildArgs(e,t,n,s)}_wsOnSignatureNotification(e){const{result:t,subscription:n}=f(e,Ps);t.value!=="receivedSignature"&&this._subscriptionsAutoDisposedByRpc.add(n),this._handleServerNotification(n,t.value==="receivedSignature"?[{type:"received"},t.context]:[{type:"status",result:t.value},t.context])}onSignature(e,t,n){const s=this._buildArgs([e],n||this._commitment||"finalized"),r=this._makeSubscription({callback:(o,a)=>{if(o.type==="status"){t(o.result,a);try{this.removeSignatureListener(r)}catch{}}},method:"signatureSubscribe",unsubscribeMethod:"signatureUnsubscribe"},s);return r}onSignatureWithOptions(e,t,n){const{commitment:s,...r}={...n,commitment:n&&n.commitment||this._commitment||"finalized"},o=this._buildArgs([e],s,void 0,r),a=this._makeSubscription({callback:(c,g)=>{t(c,g);try{this.removeSignatureListener(a)}catch{}},method:"signatureSubscribe",unsubscribeMethod:"signatureUnsubscribe"},o);return a}async removeSignatureListener(e){await this._unsubscribeClientSubscription(e,"signature result")}_wsOnRootNotification(e){const{result:t,subscription:n}=f(e,Ns);this._handleServerNotification(n,[t])}onRootChange(e){return this._makeSubscription({callback:e,method:"rootSubscribe",unsubscribeMethod:"rootUnsubscribe"},[])}async removeRootChangeListener(e){await this._unsubscribeClientSubscription(e,"root change")}}Object.freeze({CreateLookupTable:{index:0,layout:w([_("instruction"),me("recentSlot"),N("bumpSeed")])},FreezeLookupTable:{index:1,layout:w([_("instruction")])},ExtendLookupTable:{index:2,layout:w([_("instruction"),me(),G(L(),ae(_(),-8),"addresses")])},DeactivateLookupTable:{index:3,layout:w([_("instruction")])},CloseLookupTable:{index:4,layout:w([_("instruction")])}});new B("AddressLookupTab1e1111111111111111111111111");Object.freeze({RequestUnits:{index:0,layout:w([N("instruction"),_("units"),_("additionalFee")])},RequestHeapFrame:{index:1,layout:w([N("instruction"),_("bytes")])},SetComputeUnitLimit:{index:2,layout:w([N("instruction"),_("units")])},SetComputeUnitPrice:{index:3,layout:w([N("instruction"),me("microLamports")])}});new B("ComputeBudget111111111111111111111111111111");w([N("numSignatures"),N("padding"),J("signatureOffset"),J("signatureInstructionIndex"),J("publicKeyOffset"),J("publicKeyInstructionIndex"),J("messageDataOffset"),J("messageDataSize"),J("messageInstructionIndex")]);new B("Ed25519SigVerify111111111111111111111111111");wt.utils.isValidPrivateKey;wt.getPublicKey;w([N("numSignatures"),J("signatureOffset"),N("signatureInstructionIndex"),J("ethAddressOffset"),N("ethAddressInstructionIndex"),J("messageDataOffset"),J("messageDataSize"),N("messageInstructionIndex"),F(20,"ethAddress"),F(64,"signature"),N("recoveryId")]);new B("KeccakSecp256k11111111111111111111111111111");var tn;new B("StakeConfig11111111111111111111111111111111");class nn{constructor(e,t,n){this.unixTimestamp=void 0,this.epoch=void 0,this.custodian=void 0,this.unixTimestamp=e,this.epoch=t,this.custodian=n}}tn=nn;nn.default=new tn(0,0,B.default);Object.freeze({Initialize:{index:0,layout:w([_("instruction"),wn(),Sn()])},Authorize:{index:1,layout:w([_("instruction"),L("newAuthorized"),_("stakeAuthorizationType")])},Delegate:{index:2,layout:w([_("instruction")])},Split:{index:3,layout:w([_("instruction"),$("lamports")])},Withdraw:{index:4,layout:w([_("instruction"),$("lamports")])},Deactivate:{index:5,layout:w([_("instruction")])},Merge:{index:7,layout:w([_("instruction")])},AuthorizeWithSeed:{index:8,layout:w([_("instruction"),L("newAuthorized"),_("stakeAuthorizationType"),fe("authoritySeed"),L("authorityOwner")])}});new B("Stake11111111111111111111111111111111111111");Object.freeze({InitializeAccount:{index:0,layout:w([_("instruction"),kn()])},Authorize:{index:1,layout:w([_("instruction"),L("newAuthorized"),_("voteAuthorizationType")])},Withdraw:{index:3,layout:w([_("instruction"),$("lamports")])},UpdateValidatorIdentity:{index:4,layout:w([_("instruction")])},AuthorizeWithSeed:{index:10,layout:w([_("instruction"),In()])}});new B("Vote111111111111111111111111111111111111111");new B("Va1idator1nfo111111111111111111111111111111");d({name:h(),website:A(h()),details:A(h()),iconUrl:A(h()),keybaseUsername:A(h())});new B("Vote111111111111111111111111111111111111111");w([L("nodePubkey"),L("authorizedWithdrawer"),N("commission"),W(),G(w([W("slot"),_("confirmationCount")]),ae(_(),-8),"votes"),N("rootSlotValid"),W("rootSlot"),W(),G(w([W("epoch"),L("authorizedVoter")]),ae(_(),-8),"authorizedVoters"),w([G(w([L("authorizedPubkey"),W("epochOfLastAuthorizedSwitch"),W("targetEpoch")]),32,"buf"),W("idx"),N("isEmpty")],"priorVoters"),W(),G(w([W("epoch"),W("credits"),W("prevCredits")]),ae(_(),-8),"epochCredits"),w([W("slot"),W("timestamp")],"lastTimestamp")]);export{mr as C,B as P};
