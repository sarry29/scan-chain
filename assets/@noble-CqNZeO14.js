function fe(t){if(!Number.isSafeInteger(t)||t<0)throw new Error(`positive integer expected, not ${t}`)}function Ye(t){return t instanceof Uint8Array||t!=null&&typeof t=="object"&&t.constructor.name==="Uint8Array"}function Rt(t,...n){if(!Ye(t))throw new Error("Uint8Array expected");if(n.length>0&&!n.includes(t.length))throw new Error(`Uint8Array expected of length ${n}, not of length=${t.length}`)}function je(t){if(typeof t!="function"||typeof t.create!="function")throw new Error("Hash should be wrapped by utils.wrapConstructor");fe(t.outputLen),fe(t.blockLen)}function Tt(t,n=!0){if(t.destroyed)throw new Error("Hash instance has been destroyed");if(n&&t.finished)throw new Error("Hash#digest() has already been called")}function Ge(t,n){Rt(t);const e=n.outputLen;if(t.length<e)throw new Error(`digestInto() expects output buffer of length at least ${e}`)}const mt=typeof globalThis=="object"&&"crypto"in globalThis?globalThis.crypto:void 0;/*! noble-hashes - MIT License (c) 2022 Paul Miller (paulmillr.com) */const zt=t=>new DataView(t.buffer,t.byteOffset,t.byteLength),it=(t,n)=>t<<32-n|t>>>n;new Uint8Array(new Uint32Array([287454020]).buffer)[0];function Me(t){if(typeof t!="string")throw new Error(`utf8ToBytes expected string, got ${typeof t}`);return new Uint8Array(new TextEncoder().encode(t))}function Xt(t){return typeof t=="string"&&(t=Me(t)),Rt(t),t}function De(...t){let n=0;for(let r=0;r<t.length;r++){const s=t[r];Rt(s),n+=s.length}const e=new Uint8Array(n);for(let r=0,s=0;r<t.length;r++){const o=t[r];e.set(o,s),s+=o.length}return e}class me{clone(){return this._cloneInto()}}function Be(t){const n=r=>t().update(Xt(r)).digest(),e=t();return n.outputLen=e.outputLen,n.blockLen=e.blockLen,n.create=()=>t(),n}function Ee(t=32){if(mt&&typeof mt.getRandomValues=="function")return mt.getRandomValues(new Uint8Array(t));if(mt&&typeof mt.randomBytes=="function")return mt.randomBytes(t);throw new Error("crypto.getRandomValues must be defined")}function Ke(t,n,e,r){if(typeof t.setBigUint64=="function")return t.setBigUint64(n,e,r);const s=BigInt(32),o=BigInt(4294967295),c=Number(e>>s&o),f=Number(e&o),i=r?4:0,d=r?0:4;t.setUint32(n+i,c,r),t.setUint32(n+d,f,r)}const Xe=(t,n,e)=>t&n^~t&e,We=(t,n,e)=>t&n^t&e^n&e;class Se extends me{constructor(n,e,r,s){super(),this.blockLen=n,this.outputLen=e,this.padOffset=r,this.isLE=s,this.finished=!1,this.length=0,this.pos=0,this.destroyed=!1,this.buffer=new Uint8Array(n),this.view=zt(this.buffer)}update(n){Tt(this);const{view:e,buffer:r,blockLen:s}=this;n=Xt(n);const o=n.length;for(let c=0;c<o;){const f=Math.min(s-this.pos,o-c);if(f===s){const i=zt(n);for(;s<=o-c;c+=s)this.process(i,c);continue}r.set(n.subarray(c,c+f),this.pos),this.pos+=f,c+=f,this.pos===s&&(this.process(e,0),this.pos=0)}return this.length+=n.length,this.roundClean(),this}digestInto(n){Tt(this),Ge(n,this),this.finished=!0;const{buffer:e,view:r,blockLen:s,isLE:o}=this;let{pos:c}=this;e[c++]=128,this.buffer.subarray(c).fill(0),this.padOffset>s-c&&(this.process(r,0),c=0);for(let w=c;w<s;w++)e[w]=0;Ke(r,s-8,BigInt(this.length*8),o),this.process(r,0);const f=zt(n),i=this.outputLen;if(i%4)throw new Error("_sha2: outputLen should be aligned to 32bit");const d=i/4,a=this.get();if(d>a.length)throw new Error("_sha2: outputLen bigger than state");for(let w=0;w<d;w++)f.setUint32(4*w,a[w],o)}digest(){const{buffer:n,outputLen:e}=this;this.digestInto(n);const r=n.slice(0,e);return this.destroy(),r}_cloneInto(n){n||(n=new this.constructor),n.set(...this.get());const{blockLen:e,buffer:r,length:s,finished:o,destroyed:c,pos:f}=this;return n.length=s,n.pos=f,n.finished=o,n.destroyed=c,s%e&&n.buffer.set(r),n}}const Nt=BigInt(2**32-1),jt=BigInt(32);function Ae(t,n=!1){return n?{h:Number(t&Nt),l:Number(t>>jt&Nt)}:{h:Number(t>>jt&Nt)|0,l:Number(t&Nt)|0}}function Pe(t,n=!1){let e=new Uint32Array(t.length),r=new Uint32Array(t.length);for(let s=0;s<t.length;s++){const{h:o,l:c}=Ae(t[s],n);[e[s],r[s]]=[o,c]}return[e,r]}const Qe=(t,n)=>BigInt(t>>>0)<<jt|BigInt(n>>>0),Je=(t,n,e)=>t>>>e,tn=(t,n,e)=>t<<32-e|n>>>e,en=(t,n,e)=>t>>>e|n<<32-e,nn=(t,n,e)=>t<<32-e|n>>>e,rn=(t,n,e)=>t<<64-e|n>>>e-32,on=(t,n,e)=>t>>>e-32|n<<64-e,sn=(t,n)=>n,cn=(t,n)=>t,fn=(t,n,e)=>t<<e|n>>>32-e,an=(t,n,e)=>n<<e|t>>>32-e,ln=(t,n,e)=>n<<e-32|t>>>64-e,un=(t,n,e)=>t<<e-32|n>>>64-e;function dn(t,n,e,r){const s=(n>>>0)+(r>>>0);return{h:t+e+(s/2**32|0)|0,l:s|0}}const hn=(t,n,e)=>(t>>>0)+(n>>>0)+(e>>>0),gn=(t,n,e,r)=>n+e+r+(t/2**32|0)|0,wn=(t,n,e,r)=>(t>>>0)+(n>>>0)+(e>>>0)+(r>>>0),bn=(t,n,e,r,s)=>n+e+r+s+(t/2**32|0)|0,xn=(t,n,e,r,s)=>(t>>>0)+(n>>>0)+(e>>>0)+(r>>>0)+(s>>>0),yn=(t,n,e,r,s,o)=>n+e+r+s+o+(t/2**32|0)|0,T={fromBig:Ae,split:Pe,toBig:Qe,shrSH:Je,shrSL:tn,rotrSH:en,rotrSL:nn,rotrBH:rn,rotrBL:on,rotr32H:sn,rotr32L:cn,rotlSH:fn,rotlSL:an,rotlBH:ln,rotlBL:un,add:dn,add3L:hn,add3H:gn,add4L:wn,add4H:bn,add5H:yn,add5L:xn},[pn,mn]=T.split(["0x428a2f98d728ae22","0x7137449123ef65cd","0xb5c0fbcfec4d3b2f","0xe9b5dba58189dbbc","0x3956c25bf348b538","0x59f111f1b605d019","0x923f82a4af194f9b","0xab1c5ed5da6d8118","0xd807aa98a3030242","0x12835b0145706fbe","0x243185be4ee4b28c","0x550c7dc3d5ffb4e2","0x72be5d74f27b896f","0x80deb1fe3b1696b1","0x9bdc06a725c71235","0xc19bf174cf692694","0xe49b69c19ef14ad2","0xefbe4786384f25e3","0x0fc19dc68b8cd5b5","0x240ca1cc77ac9c65","0x2de92c6f592b0275","0x4a7484aa6ea6e483","0x5cb0a9dcbd41fbd4","0x76f988da831153b5","0x983e5152ee66dfab","0xa831c66d2db43210","0xb00327c898fb213f","0xbf597fc7beef0ee4","0xc6e00bf33da88fc2","0xd5a79147930aa725","0x06ca6351e003826f","0x142929670a0e6e70","0x27b70a8546d22ffc","0x2e1b21385c26c926","0x4d2c6dfc5ac42aed","0x53380d139d95b3df","0x650a73548baf63de","0x766a0abb3c77b2a8","0x81c2c92e47edaee6","0x92722c851482353b","0xa2bfe8a14cf10364","0xa81a664bbc423001","0xc24b8b70d0f89791","0xc76c51a30654be30","0xd192e819d6ef5218","0xd69906245565a910","0xf40e35855771202a","0x106aa07032bbd1b8","0x19a4c116b8d2d0c8","0x1e376c085141ab53","0x2748774cdf8eeb99","0x34b0bcb5e19b48a8","0x391c0cb3c5c95a63","0x4ed8aa4ae3418acb","0x5b9cca4f7763e373","0x682e6ff3d6b2b8a3","0x748f82ee5defb2fc","0x78a5636f43172f60","0x84c87814a1f0ab72","0x8cc702081a6439ec","0x90befffa23631e28","0xa4506cebde82bde9","0xbef9a3f7b2c67915","0xc67178f2e372532b","0xca273eceea26619c","0xd186b8c721c0c207","0xeada7dd6cde0eb1e","0xf57d4f7fee6ed178","0x06f067aa72176fba","0x0a637dc5a2c898a6","0x113f9804bef90dae","0x1b710b35131c471b","0x28db77f523047d84","0x32caab7b40c72493","0x3c9ebe0a15c9bebc","0x431d67c49c100d4c","0x4cc5d4becb3e42b6","0x597f299cfc657e2a","0x5fcb6fab3ad6faec","0x6c44198c4a475817"].map(t=>BigInt(t))),ut=new Uint32Array(80),dt=new Uint32Array(80);class Bn extends Se{constructor(){super(128,64,16,!1),this.Ah=1779033703,this.Al=-205731576,this.Bh=-1150833019,this.Bl=-2067093701,this.Ch=1013904242,this.Cl=-23791573,this.Dh=-1521486534,this.Dl=1595750129,this.Eh=1359893119,this.El=-1377402159,this.Fh=-1694144372,this.Fl=725511199,this.Gh=528734635,this.Gl=-79577749,this.Hh=1541459225,this.Hl=327033209}get(){const{Ah:n,Al:e,Bh:r,Bl:s,Ch:o,Cl:c,Dh:f,Dl:i,Eh:d,El:a,Fh:w,Fl:g,Gh:A,Gl:R,Hh:p,Hl:u}=this;return[n,e,r,s,o,c,f,i,d,a,w,g,A,R,p,u]}set(n,e,r,s,o,c,f,i,d,a,w,g,A,R,p,u){this.Ah=n|0,this.Al=e|0,this.Bh=r|0,this.Bl=s|0,this.Ch=o|0,this.Cl=c|0,this.Dh=f|0,this.Dl=i|0,this.Eh=d|0,this.El=a|0,this.Fh=w|0,this.Fl=g|0,this.Gh=A|0,this.Gl=R|0,this.Hh=p|0,this.Hl=u|0}process(n,e){for(let b=0;b<16;b++,e+=4)ut[b]=n.getUint32(e),dt[b]=n.getUint32(e+=4);for(let b=16;b<80;b++){const v=ut[b-15]|0,q=dt[b-15]|0,O=T.rotrSH(v,q,1)^T.rotrSH(v,q,8)^T.shrSH(v,q,7),H=T.rotrSL(v,q,1)^T.rotrSL(v,q,8)^T.shrSL(v,q,7),I=ut[b-2]|0,L=dt[b-2]|0,G=T.rotrSH(I,L,19)^T.rotrBH(I,L,61)^T.shrSH(I,L,6),z=T.rotrSL(I,L,19)^T.rotrBL(I,L,61)^T.shrSL(I,L,6),$=T.add4L(H,z,dt[b-7],dt[b-16]),M=T.add4H($,O,G,ut[b-7],ut[b-16]);ut[b]=M|0,dt[b]=$|0}let{Ah:r,Al:s,Bh:o,Bl:c,Ch:f,Cl:i,Dh:d,Dl:a,Eh:w,El:g,Fh:A,Fl:R,Gh:p,Gl:u,Hh:y,Hl:S}=this;for(let b=0;b<80;b++){const v=T.rotrSH(w,g,14)^T.rotrSH(w,g,18)^T.rotrBH(w,g,41),q=T.rotrSL(w,g,14)^T.rotrSL(w,g,18)^T.rotrBL(w,g,41),O=w&A^~w&p,H=g&R^~g&u,I=T.add5L(S,q,H,mn[b],dt[b]),L=T.add5H(I,y,v,O,pn[b],ut[b]),G=I|0,z=T.rotrSH(r,s,28)^T.rotrBH(r,s,34)^T.rotrBH(r,s,39),$=T.rotrSL(r,s,28)^T.rotrBL(r,s,34)^T.rotrBL(r,s,39),M=r&o^r&f^o&f,m=s&c^s&i^c&i;y=p|0,S=u|0,p=A|0,u=R|0,A=w|0,R=g|0,{h:w,l:g}=T.add(d|0,a|0,L|0,G|0),d=f|0,a=i|0,f=o|0,i=c|0,o=r|0,c=s|0;const B=T.add3L(G,$,m);r=T.add3H(B,L,z,M),s=B|0}({h:r,l:s}=T.add(this.Ah|0,this.Al|0,r|0,s|0)),{h:o,l:c}=T.add(this.Bh|0,this.Bl|0,o|0,c|0),{h:f,l:i}=T.add(this.Ch|0,this.Cl|0,f|0,i|0),{h:d,l:a}=T.add(this.Dh|0,this.Dl|0,d|0,a|0),{h:w,l:g}=T.add(this.Eh|0,this.El|0,w|0,g|0),{h:A,l:R}=T.add(this.Fh|0,this.Fl|0,A|0,R|0),{h:p,l:u}=T.add(this.Gh|0,this.Gl|0,p|0,u|0),{h:y,l:S}=T.add(this.Hh|0,this.Hl|0,y|0,S|0),this.set(r,s,o,c,f,i,d,a,w,g,A,R,p,u,y,S)}roundClean(){ut.fill(0),dt.fill(0)}destroy(){this.buffer.fill(0),this.set(0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0)}}const En=Be(()=>new Bn);/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */const Wt=BigInt(0),$t=BigInt(1),Sn=BigInt(2);function xt(t){return t instanceof Uint8Array||t!=null&&typeof t=="object"&&t.constructor.name==="Uint8Array"}function Ot(t){if(!xt(t))throw new Error("Uint8Array expected")}function lt(t,n){if(typeof n!="boolean")throw new Error(`${t} must be valid boolean, got "${n}".`)}const An=Array.from({length:256},(t,n)=>n.toString(16).padStart(2,"0"));function yt(t){Ot(t);let n="";for(let e=0;e<t.length;e++)n+=An[t[e]];return n}function Bt(t){const n=t.toString(16);return n.length&1?`0${n}`:n}function Pt(t){if(typeof t!="string")throw new Error("hex string expected, got "+typeof t);return BigInt(t===""?"0":`0x${t}`)}const ct={_0:48,_9:57,_A:65,_F:70,_a:97,_f:102};function ae(t){if(t>=ct._0&&t<=ct._9)return t-ct._0;if(t>=ct._A&&t<=ct._F)return t-(ct._A-10);if(t>=ct._a&&t<=ct._f)return t-(ct._a-10)}function St(t){if(typeof t!="string")throw new Error("hex string expected, got "+typeof t);const n=t.length,e=n/2;if(n%2)throw new Error("padded hex string expected, got unpadded hex of length "+n);const r=new Uint8Array(e);for(let s=0,o=0;s<e;s++,o+=2){const c=ae(t.charCodeAt(o)),f=ae(t.charCodeAt(o+1));if(c===void 0||f===void 0){const i=t[o]+t[o+1];throw new Error('hex string expected, got non-hex character "'+i+'" at index '+o)}r[s]=c*16+f}return r}function bt(t){return Pt(yt(t))}function Et(t){return Ot(t),Pt(yt(Uint8Array.from(t).reverse()))}function At(t,n){return St(t.toString(16).padStart(n*2,"0"))}function Lt(t,n){return At(t,n).reverse()}function vn(t){return St(Bt(t))}function K(t,n,e){let r;if(typeof n=="string")try{r=St(n)}catch(o){throw new Error(`${t} must be valid hex string, got "${n}". Cause: ${o}`)}else if(xt(n))r=Uint8Array.from(n);else throw new Error(`${t} must be hex string or Uint8Array`);const s=r.length;if(typeof e=="number"&&s!==e)throw new Error(`${t} expected ${e} bytes, got ${s}`);return r}function pt(...t){let n=0;for(let r=0;r<t.length;r++){const s=t[r];Ot(s),n+=s.length}const e=new Uint8Array(n);for(let r=0,s=0;r<t.length;r++){const o=t[r];e.set(o,s),s+=o.length}return e}function In(t,n){if(t.length!==n.length)return!1;let e=0;for(let r=0;r<t.length;r++)e|=t[r]^n[r];return e===0}function Hn(t){if(typeof t!="string")throw new Error(`utf8ToBytes expected string, got ${typeof t}`);return new Uint8Array(new TextEncoder().encode(t))}const kt=t=>typeof t=="bigint"&&Wt<=t;function Ut(t,n,e){return kt(t)&&kt(n)&&kt(e)&&n<=t&&t<e}function rt(t,n,e,r){if(!Ut(n,e,r))throw new Error(`expected valid ${t}: ${e} <= n < ${r}, got ${typeof n} ${n}`)}function ve(t){let n;for(n=0;t>Wt;t>>=$t,n+=1);return n}function Ln(t,n){return t>>BigInt(n)&$t}function _n(t,n,e){return t|(e?$t:Wt)<<BigInt(n)}const Qt=t=>(Sn<<BigInt(t-1))-$t,Vt=t=>new Uint8Array(t),le=t=>Uint8Array.from(t);function Ie(t,n,e){if(typeof t!="number"||t<2)throw new Error("hashLen must be a number");if(typeof n!="number"||n<2)throw new Error("qByteLen must be a number");if(typeof e!="function")throw new Error("hmacFn must be a function");let r=Vt(t),s=Vt(t),o=0;const c=()=>{r.fill(1),s.fill(0),o=0},f=(...w)=>e(s,r,...w),i=(w=Vt())=>{s=f(le([0]),w),r=f(),w.length!==0&&(s=f(le([1]),w),r=f())},d=()=>{if(o++>=1e3)throw new Error("drbg: tried 1000 values");let w=0;const g=[];for(;w<n;){r=f();const A=r.slice();g.push(A),w+=r.length}return pt(...g)};return(w,g)=>{c(),i(w);let A;for(;!(A=g(d()));)i();return c(),A}}const On={bigint:t=>typeof t=="bigint",function:t=>typeof t=="function",boolean:t=>typeof t=="boolean",string:t=>typeof t=="string",stringOrUint8Array:t=>typeof t=="string"||xt(t),isSafeInteger:t=>Number.isSafeInteger(t),array:t=>Array.isArray(t),field:(t,n)=>n.Fp.isValid(t),hash:t=>typeof t=="function"&&Number.isSafeInteger(t.outputLen)};function vt(t,n,e={}){const r=(s,o,c)=>{const f=On[o];if(typeof f!="function")throw new Error(`Invalid validator "${o}", expected function`);const i=t[s];if(!(c&&i===void 0)&&!f(i,t))throw new Error(`Invalid param ${String(s)}=${i} (${typeof i}), expected ${o}`)};for(const[s,o]of Object.entries(n))r(s,o,!1);for(const[s,o]of Object.entries(e))r(s,o,!0);return t}const Nn=()=>{throw new Error("not implemented")};function _t(t){const n=new WeakMap;return(e,...r)=>{const s=n.get(e);if(s!==void 0)return s;const o=t(e,...r);return n.set(e,o),o}}const qn=Object.freeze(Object.defineProperty({__proto__:null,aInRange:rt,abool:lt,abytes:Ot,bitGet:Ln,bitLen:ve,bitMask:Qt,bitSet:_n,bytesToHex:yt,bytesToNumberBE:bt,bytesToNumberLE:Et,concatBytes:pt,createHmacDrbg:Ie,ensureBytes:K,equalBytes:In,hexToBytes:St,hexToNumber:Pt,inRange:Ut,isBytes:xt,memoized:_t,notImplemented:Nn,numberToBytesBE:At,numberToBytesLE:Lt,numberToHexUnpadded:Bt,numberToVarBytesBE:vn,utf8ToBytes:Hn,validateObject:vt},Symbol.toStringTag,{value:"Module"}));/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */const Q=BigInt(0),Y=BigInt(1),wt=BigInt(2),Tn=BigInt(3),Gt=BigInt(4),ue=BigInt(5),de=BigInt(8);BigInt(9);BigInt(16);function F(t,n){const e=t%n;return e>=Q?e:n+e}function Rn(t,n,e){if(e<=Q||n<Q)throw new Error("Expected power/modulo > 0");if(e===Y)return Q;let r=Y;for(;n>Q;)n&Y&&(r=r*t%e),t=t*t%e,n>>=Y;return r}function j(t,n,e){let r=t;for(;n-- >Q;)r*=r,r%=e;return r}function Mt(t,n){if(t===Q||n<=Q)throw new Error(`invert: expected positive integers, got n=${t} mod=${n}`);let e=F(t,n),r=n,s=Q,o=Y;for(;e!==Q;){const f=r/e,i=r%e,d=s-o*f;r=e,e=i,s=o,o=d}if(r!==Y)throw new Error("invert: does not exist");return F(s,n)}function $n(t){const n=(t-Y)/wt;let e,r,s;for(e=t-Y,r=0;e%wt===Q;e/=wt,r++);for(s=wt;s<t&&Rn(s,n,t)!==t-Y;s++);if(r===1){const c=(t+Y)/Gt;return function(i,d){const a=i.pow(d,c);if(!i.eql(i.sqr(a),d))throw new Error("Cannot find square root");return a}}const o=(e+Y)/wt;return function(f,i){if(f.pow(i,n)===f.neg(f.ONE))throw new Error("Cannot find square root");let d=r,a=f.pow(f.mul(f.ONE,s),e),w=f.pow(i,o),g=f.pow(i,e);for(;!f.eql(g,f.ONE);){if(f.eql(g,f.ZERO))return f.ZERO;let A=1;for(let p=f.sqr(g);A<d&&!f.eql(p,f.ONE);A++)p=f.sqr(p);const R=f.pow(a,Y<<BigInt(d-A-1));a=f.sqr(R),w=f.mul(w,R),g=f.mul(g,a),d=A}return w}}function Un(t){if(t%Gt===Tn){const n=(t+Y)/Gt;return function(r,s){const o=r.pow(s,n);if(!r.eql(r.sqr(o),s))throw new Error("Cannot find square root");return o}}if(t%de===ue){const n=(t-ue)/de;return function(r,s){const o=r.mul(s,wt),c=r.pow(o,n),f=r.mul(s,c),i=r.mul(r.mul(f,wt),c),d=r.mul(f,r.sub(i,r.ONE));if(!r.eql(r.sqr(d),s))throw new Error("Cannot find square root");return d}}return $n(t)}const Zn=(t,n)=>(F(t,n)&Y)===Y,Cn=["create","isValid","is0","neg","inv","sqrt","sqr","eql","add","sub","mul","pow","div","addN","subN","mulN","sqrN"];function zn(t){const n={ORDER:"bigint",MASK:"bigint",BYTES:"isSafeInteger",BITS:"isSafeInteger"},e=Cn.reduce((r,s)=>(r[s]="function",r),n);return vt(t,e)}function kn(t,n,e){if(e<Q)throw new Error("Expected power > 0");if(e===Q)return t.ONE;if(e===Y)return n;let r=t.ONE,s=n;for(;e>Q;)e&Y&&(r=t.mul(r,s)),s=t.sqr(s),e>>=Y;return r}function Vn(t,n){const e=new Array(n.length),r=n.reduce((o,c,f)=>t.is0(c)?o:(e[f]=o,t.mul(o,c)),t.ONE),s=t.inv(r);return n.reduceRight((o,c,f)=>t.is0(c)?o:(e[f]=t.mul(o,e[f]),t.mul(o,c)),s),e}function He(t,n){const e=n!==void 0?n:t.toString(2).length,r=Math.ceil(e/8);return{nBitLength:e,nByteLength:r}}function Zt(t,n,e=!1,r={}){if(t<=Q)throw new Error(`Expected Field ORDER > 0, got ${t}`);const{nBitLength:s,nByteLength:o}=He(t,n);if(o>2048)throw new Error("Field lengths over 2048 bytes are not supported");const c=Un(t),f=Object.freeze({ORDER:t,BITS:s,BYTES:o,MASK:Qt(s),ZERO:Q,ONE:Y,create:i=>F(i,t),isValid:i=>{if(typeof i!="bigint")throw new Error(`Invalid field element: expected bigint, got ${typeof i}`);return Q<=i&&i<t},is0:i=>i===Q,isOdd:i=>(i&Y)===Y,neg:i=>F(-i,t),eql:(i,d)=>i===d,sqr:i=>F(i*i,t),add:(i,d)=>F(i+d,t),sub:(i,d)=>F(i-d,t),mul:(i,d)=>F(i*d,t),pow:(i,d)=>kn(f,i,d),div:(i,d)=>F(i*Mt(d,t),t),sqrN:i=>i*i,addN:(i,d)=>i+d,subN:(i,d)=>i-d,mulN:(i,d)=>i*d,inv:i=>Mt(i,t),sqrt:r.sqrt||(i=>c(f,i)),invertBatch:i=>Vn(f,i),cmov:(i,d,a)=>a?d:i,toBytes:i=>e?Lt(i,o):At(i,o),fromBytes:i=>{if(i.length!==o)throw new Error(`Fp.fromBytes: expected ${o}, got ${i.length}`);return e?Et(i):bt(i)}});return Object.freeze(f)}function Le(t){if(typeof t!="bigint")throw new Error("field order must be bigint");const n=t.toString(2).length;return Math.ceil(n/8)}function _e(t){const n=Le(t);return n+Math.ceil(n/2)}function Fn(t,n,e=!1){const r=t.length,s=Le(n),o=_e(n);if(r<16||r<o||r>1024)throw new Error(`expected ${o}-1024 bytes of input, got ${r}`);const c=e?bt(t):Et(t),f=F(c,n-Y)+Y;return e?Lt(f,s):At(f,s)}/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */const Yn=BigInt(0),Ft=BigInt(1),Yt=new WeakMap,he=new WeakMap;function Oe(t,n){const e=(o,c)=>{const f=c.negate();return o?f:c},r=o=>{if(!Number.isSafeInteger(o)||o<=0||o>n)throw new Error(`Wrong window size=${o}, should be [1..${n}]`)},s=o=>{r(o);const c=Math.ceil(n/o)+1,f=2**(o-1);return{windows:c,windowSize:f}};return{constTimeNegate:e,unsafeLadder(o,c){let f=t.ZERO,i=o;for(;c>Yn;)c&Ft&&(f=f.add(i)),i=i.double(),c>>=Ft;return f},precomputeWindow(o,c){const{windows:f,windowSize:i}=s(c),d=[];let a=o,w=a;for(let g=0;g<f;g++){w=a,d.push(w);for(let A=1;A<i;A++)w=w.add(a),d.push(w);a=w.double()}return d},wNAF(o,c,f){const{windows:i,windowSize:d}=s(o);let a=t.ZERO,w=t.BASE;const g=BigInt(2**o-1),A=2**o,R=BigInt(o);for(let p=0;p<i;p++){const u=p*d;let y=Number(f&g);f>>=R,y>d&&(y-=A,f+=Ft);const S=u,b=u+Math.abs(y)-1,v=p%2!==0,q=y<0;y===0?w=w.add(e(v,c[S])):a=a.add(e(q,c[b]))}return{p:a,f:w}},wNAFCached(o,c,f){const i=he.get(o)||1;let d=Yt.get(o);return d||(d=this.precomputeWindow(o,i),i!==1&&Yt.set(o,f(d))),this.wNAF(i,d,c)},setWindowSize(o,c){r(c),he.set(o,c),Yt.delete(o)}}}function Ne(t,n,e,r){if(!Array.isArray(e)||!Array.isArray(r)||r.length!==e.length)throw new Error("arrays of points and scalars must have equal length");r.forEach((a,w)=>{if(!n.isValid(a))throw new Error(`wrong scalar at index ${w}`)}),e.forEach((a,w)=>{if(!(a instanceof t))throw new Error(`wrong point at index ${w}`)});const s=ve(BigInt(e.length)),o=s>12?s-3:s>4?s-2:s?2:1,c=(1<<o)-1,f=new Array(c+1).fill(t.ZERO),i=Math.floor((n.BITS-1)/o)*o;let d=t.ZERO;for(let a=i;a>=0;a-=o){f.fill(t.ZERO);for(let g=0;g<r.length;g++){const A=r[g],R=Number(A>>BigInt(a)&BigInt(c));f[R]=f[R].add(e[g])}let w=t.ZERO;for(let g=f.length-1,A=t.ZERO;g>0;g--)A=A.add(f[g]),w=w.add(A);if(d=d.add(w),a!==0)for(let g=0;g<o;g++)d=d.double()}return d}function Jt(t){return zn(t.Fp),vt(t,{n:"bigint",h:"bigint",Gx:"field",Gy:"field"},{nBitLength:"isSafeInteger",nByteLength:"isSafeInteger"}),Object.freeze({...He(t.n,t.nBitLength),...t,p:t.Fp.ORDER})}/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */const st=BigInt(0),nt=BigInt(1),qt=BigInt(2),jn=BigInt(8),Gn={zip215:!0};function Mn(t){const n=Jt(t);return vt(t,{hash:"function",a:"bigint",d:"bigint",randomBytes:"function"},{adjustScalarBytes:"function",domain:"function",uvRatio:"function",mapToCurve:"function"}),Object.freeze({...n})}function Dn(t){const n=Mn(t),{Fp:e,n:r,prehash:s,hash:o,randomBytes:c,nByteLength:f,h:i}=n,d=qt<<BigInt(f*8)-nt,a=e.create,w=Zt(n.n,n.nBitLength),g=n.uvRatio||((h,l)=>{try{return{isValid:!0,value:e.sqrt(h*e.inv(l))}}catch{return{isValid:!1,value:st}}}),A=n.adjustScalarBytes||(h=>h),R=n.domain||((h,l,x)=>{if(lt("phflag",x),l.length||x)throw new Error("Contexts/pre-hash are not supported");return h});function p(h,l){rt("coordinate "+h,l,st,d)}function u(h){if(!(h instanceof b))throw new Error("ExtendedPoint expected")}const y=_t((h,l)=>{const{ex:x,ey:E,ez:_}=h,N=h.is0();l==null&&(l=N?jn:e.inv(_));const U=a(x*l),C=a(E*l),Z=a(_*l);if(N)return{x:st,y:nt};if(Z!==nt)throw new Error("invZ was invalid");return{x:U,y:C}}),S=_t(h=>{const{a:l,d:x}=n;if(h.is0())throw new Error("bad point: ZERO");const{ex:E,ey:_,ez:N,et:U}=h,C=a(E*E),Z=a(_*_),k=a(N*N),V=a(k*k),X=a(C*l),W=a(k*a(X+Z)),J=a(V+a(x*a(C*Z)));if(W!==J)throw new Error("bad point: equation left != right (1)");const tt=a(E*_),et=a(N*U);if(tt!==et)throw new Error("bad point: equation left != right (2)");return!0});class b{constructor(l,x,E,_){this.ex=l,this.ey=x,this.ez=E,this.et=_,p("x",l),p("y",x),p("z",E),p("t",_),Object.freeze(this)}get x(){return this.toAffine().x}get y(){return this.toAffine().y}static fromAffine(l){if(l instanceof b)throw new Error("extended point not allowed");const{x,y:E}=l||{};return p("x",x),p("y",E),new b(x,E,nt,a(x*E))}static normalizeZ(l){const x=e.invertBatch(l.map(E=>E.ez));return l.map((E,_)=>E.toAffine(x[_])).map(b.fromAffine)}static msm(l,x){return Ne(b,w,l,x)}_setWindowSize(l){O.setWindowSize(this,l)}assertValidity(){S(this)}equals(l){u(l);const{ex:x,ey:E,ez:_}=this,{ex:N,ey:U,ez:C}=l,Z=a(x*C),k=a(N*_),V=a(E*C),X=a(U*_);return Z===k&&V===X}is0(){return this.equals(b.ZERO)}negate(){return new b(a(-this.ex),this.ey,this.ez,a(-this.et))}double(){const{a:l}=n,{ex:x,ey:E,ez:_}=this,N=a(x*x),U=a(E*E),C=a(qt*a(_*_)),Z=a(l*N),k=x+E,V=a(a(k*k)-N-U),X=Z+U,W=X-C,J=Z-U,tt=a(V*W),et=a(X*J),D=a(V*J),ot=a(W*X);return new b(tt,et,ot,D)}add(l){u(l);const{a:x,d:E}=n,{ex:_,ey:N,ez:U,et:C}=this,{ex:Z,ey:k,ez:V,et:X}=l;if(x===BigInt(-1)){const ee=a((N-_)*(k+Z)),ne=a((N+_)*(k-Z)),Ct=a(ne-ee);if(Ct===st)return this.double();const re=a(U*qt*X),oe=a(C*qt*V),se=oe+re,ie=ne+ee,ce=oe-re,ze=a(se*Ct),ke=a(ie*ce),Ve=a(se*ce),Fe=a(Ct*ie);return new b(ze,ke,Fe,Ve)}const W=a(_*Z),J=a(N*k),tt=a(C*E*X),et=a(U*V),D=a((_+N)*(Z+k)-W-J),ot=et-tt,It=et+tt,Ht=a(J-x*W),$e=a(D*ot),Ue=a(It*Ht),Ze=a(D*Ht),Ce=a(ot*It);return new b($e,Ue,Ce,Ze)}subtract(l){return this.add(l.negate())}wNAF(l){return O.wNAFCached(this,l,b.normalizeZ)}multiply(l){const x=l;rt("scalar",x,nt,r);const{p:E,f:_}=this.wNAF(x);return b.normalizeZ([E,_])[0]}multiplyUnsafe(l){const x=l;return rt("scalar",x,st,r),x===st?q:this.equals(q)||x===nt?this:this.equals(v)?this.wNAF(x).p:O.unsafeLadder(this,x)}isSmallOrder(){return this.multiplyUnsafe(i).is0()}isTorsionFree(){return O.unsafeLadder(this,r).is0()}toAffine(l){return y(this,l)}clearCofactor(){const{h:l}=n;return l===nt?this:this.multiplyUnsafe(l)}static fromHex(l,x=!1){const{d:E,a:_}=n,N=e.BYTES;l=K("pointHex",l,N),lt("zip215",x);const U=l.slice(),C=l[N-1];U[N-1]=C&-129;const Z=Et(U),k=x?d:e.ORDER;rt("pointHex.y",Z,st,k);const V=a(Z*Z),X=a(V-nt),W=a(E*V-_);let{isValid:J,value:tt}=g(X,W);if(!J)throw new Error("Point.fromHex: invalid y coordinate");const et=(tt&nt)===nt,D=(C&128)!==0;if(!x&&tt===st&&D)throw new Error("Point.fromHex: x=0 and x_0=1");return D!==et&&(tt=a(-tt)),b.fromAffine({x:tt,y:Z})}static fromPrivateKey(l){return L(l).point}toRawBytes(){const{x:l,y:x}=this.toAffine(),E=Lt(x,e.BYTES);return E[E.length-1]|=l&nt?128:0,E}toHex(){return yt(this.toRawBytes())}}b.BASE=new b(n.Gx,n.Gy,nt,a(n.Gx*n.Gy)),b.ZERO=new b(st,nt,nt,st);const{BASE:v,ZERO:q}=b,O=Oe(b,f*8);function H(h){return F(h,r)}function I(h){return H(Et(h))}function L(h){const l=f;h=K("private key",h,l);const x=K("hashed private key",o(h),2*l),E=A(x.slice(0,l)),_=x.slice(l,2*l),N=I(E),U=v.multiply(N),C=U.toRawBytes();return{head:E,prefix:_,scalar:N,point:U,pointBytes:C}}function G(h){return L(h).pointBytes}function z(h=new Uint8Array,...l){const x=pt(...l);return I(o(R(x,K("context",h),!!s)))}function $(h,l,x={}){h=K("message",h),s&&(h=s(h));const{prefix:E,scalar:_,pointBytes:N}=L(l),U=z(x.context,E,h),C=v.multiply(U).toRawBytes(),Z=z(x.context,C,N,h),k=H(U+Z*_);rt("signature.s",k,st,r);const V=pt(C,Lt(k,e.BYTES));return K("result",V,f*2)}const M=Gn;function m(h,l,x,E=M){const{context:_,zip215:N}=E,U=e.BYTES;h=K("signature",h,2*U),l=K("message",l),N!==void 0&&lt("zip215",N),s&&(l=s(l));const C=Et(h.slice(U,2*U));let Z,k,V;try{Z=b.fromHex(x,N),k=b.fromHex(h.slice(0,U),N),V=v.multiplyUnsafe(C)}catch{return!1}if(!N&&Z.isSmallOrder())return!1;const X=z(_,k.toRawBytes(),Z.toRawBytes(),l);return k.add(Z.multiplyUnsafe(X)).subtract(V).clearCofactor().equals(b.ZERO)}return v._setWindowSize(8),{CURVE:n,getPublicKey:G,sign:$,verify:m,ExtendedPoint:b,utils:{getExtendedPublicKey:L,randomPrivateKey:()=>c(e.BYTES),precompute(h=8,l=b.BASE){return l._setWindowSize(h),l.multiply(BigInt(3)),l}}}}/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */const te=BigInt("57896044618658097711785492504343953926634992332820282019728792003956564819949"),ge=BigInt("19681161376707505956807079304988542015446066515923890162744021073123829784752");BigInt(0);const Kn=BigInt(1),we=BigInt(2);BigInt(3);const Xn=BigInt(5),Wn=BigInt(8);function Pn(t){const n=BigInt(10),e=BigInt(20),r=BigInt(40),s=BigInt(80),o=te,f=t*t%o*t%o,i=j(f,we,o)*f%o,d=j(i,Kn,o)*t%o,a=j(d,Xn,o)*d%o,w=j(a,n,o)*a%o,g=j(w,e,o)*w%o,A=j(g,r,o)*g%o,R=j(A,s,o)*A%o,p=j(R,s,o)*A%o,u=j(p,n,o)*a%o;return{pow_p_5_8:j(u,we,o)*t%o,b2:f}}function Qn(t){return t[0]&=248,t[31]&=127,t[31]|=64,t}function Jn(t,n){const e=te,r=F(n*n*n,e),s=F(r*r*n,e),o=Pn(t*s).pow_p_5_8;let c=F(t*r*o,e);const f=F(n*c*c,e),i=c,d=F(c*ge,e),a=f===t,w=f===F(-t,e),g=f===F(-t*ge,e);return a&&(c=i),(w||g)&&(c=d),Zn(c,e)&&(c=F(-c,e)),{isValid:a||w,value:c}}const tr=Zt(te,void 0,!0),er={a:BigInt(-1),d:BigInt("37095705934669439343138083508754565189542113879843219016388785533085940283555"),Fp:tr,n:BigInt("7237005577332262213973186563042994240857116359379907606001950938285454250989"),h:Wn,Gx:BigInt("15112221349535400772501151409588531511454012693041857206046113283949847762202"),Gy:BigInt("46316835694926478169428394003475163141307993866256225615783033603165251855960"),hash:En,randomBytes:Ee,adjustScalarBytes:Qn,uvRatio:Jn},br=Dn(er),nr=new Uint32Array([1116352408,1899447441,3049323471,3921009573,961987163,1508970993,2453635748,2870763221,3624381080,310598401,607225278,1426881987,1925078388,2162078206,2614888103,3248222580,3835390401,4022224774,264347078,604807628,770255983,1249150122,1555081692,1996064986,2554220882,2821834349,2952996808,3210313671,3336571891,3584528711,113926993,338241895,666307205,773529912,1294757372,1396182291,1695183700,1986661051,2177026350,2456956037,2730485921,2820302411,3259730800,3345764771,3516065817,3600352804,4094571909,275423344,430227734,506948616,659060556,883997877,958139571,1322822218,1537002063,1747873779,1955562222,2024104815,2227730452,2361852424,2428436474,2756734187,3204031479,3329325298]),ht=new Uint32Array([1779033703,3144134277,1013904242,2773480762,1359893119,2600822924,528734635,1541459225]),gt=new Uint32Array(64);class rr extends Se{constructor(){super(64,32,8,!1),this.A=ht[0]|0,this.B=ht[1]|0,this.C=ht[2]|0,this.D=ht[3]|0,this.E=ht[4]|0,this.F=ht[5]|0,this.G=ht[6]|0,this.H=ht[7]|0}get(){const{A:n,B:e,C:r,D:s,E:o,F:c,G:f,H:i}=this;return[n,e,r,s,o,c,f,i]}set(n,e,r,s,o,c,f,i){this.A=n|0,this.B=e|0,this.C=r|0,this.D=s|0,this.E=o|0,this.F=c|0,this.G=f|0,this.H=i|0}process(n,e){for(let w=0;w<16;w++,e+=4)gt[w]=n.getUint32(e,!1);for(let w=16;w<64;w++){const g=gt[w-15],A=gt[w-2],R=it(g,7)^it(g,18)^g>>>3,p=it(A,17)^it(A,19)^A>>>10;gt[w]=p+gt[w-7]+R+gt[w-16]|0}let{A:r,B:s,C:o,D:c,E:f,F:i,G:d,H:a}=this;for(let w=0;w<64;w++){const g=it(f,6)^it(f,11)^it(f,25),A=a+g+Xe(f,i,d)+nr[w]+gt[w]|0,p=(it(r,2)^it(r,13)^it(r,22))+We(r,s,o)|0;a=d,d=i,i=f,f=c+A|0,c=o,o=s,s=r,r=A+p|0}r=r+this.A|0,s=s+this.B|0,o=o+this.C|0,c=c+this.D|0,f=f+this.E|0,i=i+this.F|0,d=d+this.G|0,a=a+this.H|0,this.set(r,s,o,c,f,i,d,a)}roundClean(){gt.fill(0)}destroy(){this.set(0,0,0,0,0,0,0,0),this.buffer.fill(0)}}const or=Be(()=>new rr);class qe extends me{constructor(n,e){super(),this.finished=!1,this.destroyed=!1,je(n);const r=Xt(e);if(this.iHash=n.create(),typeof this.iHash.update!="function")throw new Error("Expected instance of class which extends utils.Hash");this.blockLen=this.iHash.blockLen,this.outputLen=this.iHash.outputLen;const s=this.blockLen,o=new Uint8Array(s);o.set(r.length>s?n.create().update(r).digest():r);for(let c=0;c<o.length;c++)o[c]^=54;this.iHash.update(o),this.oHash=n.create();for(let c=0;c<o.length;c++)o[c]^=106;this.oHash.update(o),o.fill(0)}update(n){return Tt(this),this.iHash.update(n),this}digestInto(n){Tt(this),Rt(n,this.outputLen),this.finished=!0,this.iHash.digestInto(n),this.oHash.update(n),this.oHash.digestInto(n),this.destroy()}digest(){const n=new Uint8Array(this.oHash.outputLen);return this.digestInto(n),n}_cloneInto(n){n||(n=Object.create(Object.getPrototypeOf(this),{}));const{oHash:e,iHash:r,finished:s,destroyed:o,blockLen:c,outputLen:f}=this;return n=n,n.finished=s,n.destroyed=o,n.blockLen=c,n.outputLen=f,n.oHash=e._cloneInto(n.oHash),n.iHash=r._cloneInto(n.iHash),n}destroy(){this.destroyed=!0,this.oHash.destroy(),this.iHash.destroy()}}const Te=(t,n,e)=>new qe(t,n).update(e).digest();Te.create=(t,n)=>new qe(t,n);/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */function be(t){t.lowS!==void 0&&lt("lowS",t.lowS),t.prehash!==void 0&&lt("prehash",t.prehash)}function sr(t){const n=Jt(t);vt(n,{a:"field",b:"field"},{allowedPrivateKeyLengths:"array",wrapPrivateKey:"boolean",isTorsionFree:"function",clearCofactor:"function",allowInfinityPoint:"boolean",fromBytes:"function",toBytes:"function"});const{endo:e,Fp:r,a:s}=n;if(e){if(!r.eql(s,r.ZERO))throw new Error("Endomorphism can only be defined for Koblitz curves that have a=0");if(typeof e!="object"||typeof e.beta!="bigint"||typeof e.splitScalar!="function")throw new Error("Expected endomorphism with beta: bigint and splitScalar: function")}return Object.freeze({...n})}const{bytesToNumberBE:ir,hexToBytes:cr}=qn,ft={Err:class extends Error{constructor(n=""){super(n)}},_tlv:{encode:(t,n)=>{const{Err:e}=ft;if(t<0||t>256)throw new e("tlv.encode: wrong tag");if(n.length&1)throw new e("tlv.encode: unpadded data");const r=n.length/2,s=Bt(r);if(s.length/2&128)throw new e("tlv.encode: long form length too big");const o=r>127?Bt(s.length/2|128):"";return`${Bt(t)}${o}${s}${n}`},decode(t,n){const{Err:e}=ft;let r=0;if(t<0||t>256)throw new e("tlv.encode: wrong tag");if(n.length<2||n[r++]!==t)throw new e("tlv.decode: wrong tlv");const s=n[r++],o=!!(s&128);let c=0;if(!o)c=s;else{const i=s&127;if(!i)throw new e("tlv.decode(long): indefinite length not supported");if(i>4)throw new e("tlv.decode(long): byte length is too big");const d=n.subarray(r,r+i);if(d.length!==i)throw new e("tlv.decode: length bytes not complete");if(d[0]===0)throw new e("tlv.decode(long): zero leftmost byte");for(const a of d)c=c<<8|a;if(r+=i,c<128)throw new e("tlv.decode(long): not minimal encoding")}const f=n.subarray(r,r+c);if(f.length!==c)throw new e("tlv.decode: wrong value length");return{v:f,l:n.subarray(r+c)}}},_int:{encode(t){const{Err:n}=ft;if(t<at)throw new n("integer: negative integers are not allowed");let e=Bt(t);if(Number.parseInt(e[0],16)&8&&(e="00"+e),e.length&1)throw new n("unexpected assertion");return e},decode(t){const{Err:n}=ft;if(t[0]&128)throw new n("Invalid signature integer: negative");if(t[0]===0&&!(t[1]&128))throw new n("Invalid signature integer: unnecessary leading zero");return ir(t)}},toSig(t){const{Err:n,_int:e,_tlv:r}=ft,s=typeof t=="string"?cr(t):t;Ot(s);const{v:o,l:c}=r.decode(48,s);if(c.length)throw new n("Invalid signature: left bytes after parsing");const{v:f,l:i}=r.decode(2,o),{v:d,l:a}=r.decode(2,i);if(a.length)throw new n("Invalid signature: left bytes after parsing");return{r:e.decode(f),s:e.decode(d)}},hexFromSig(t){const{_tlv:n,_int:e}=ft,r=`${n.encode(2,e.encode(t.r))}${n.encode(2,e.encode(t.s))}`;return n.encode(48,r)}},at=BigInt(0),P=BigInt(1);BigInt(2);const xe=BigInt(3);BigInt(4);function fr(t){const n=sr(t),{Fp:e}=n,r=Zt(n.n,n.nBitLength),s=n.toBytes||((p,u,y)=>{const S=u.toAffine();return pt(Uint8Array.from([4]),e.toBytes(S.x),e.toBytes(S.y))}),o=n.fromBytes||(p=>{const u=p.subarray(1),y=e.fromBytes(u.subarray(0,e.BYTES)),S=e.fromBytes(u.subarray(e.BYTES,2*e.BYTES));return{x:y,y:S}});function c(p){const{a:u,b:y}=n,S=e.sqr(p),b=e.mul(S,p);return e.add(e.add(b,e.mul(p,u)),y)}if(!e.eql(e.sqr(n.Gy),c(n.Gx)))throw new Error("bad generator point: equation left != right");function f(p){return Ut(p,P,n.n)}function i(p){const{allowedPrivateKeyLengths:u,nByteLength:y,wrapPrivateKey:S,n:b}=n;if(u&&typeof p!="bigint"){if(xt(p)&&(p=yt(p)),typeof p!="string"||!u.includes(p.length))throw new Error("Invalid key");p=p.padStart(y*2,"0")}let v;try{v=typeof p=="bigint"?p:bt(K("private key",p,y))}catch{throw new Error(`private key must be ${y} bytes, hex or bigint, not ${typeof p}`)}return S&&(v=F(v,b)),rt("private key",v,P,b),v}function d(p){if(!(p instanceof g))throw new Error("ProjectivePoint expected")}const a=_t((p,u)=>{const{px:y,py:S,pz:b}=p;if(e.eql(b,e.ONE))return{x:y,y:S};const v=p.is0();u==null&&(u=v?e.ONE:e.inv(b));const q=e.mul(y,u),O=e.mul(S,u),H=e.mul(b,u);if(v)return{x:e.ZERO,y:e.ZERO};if(!e.eql(H,e.ONE))throw new Error("invZ was invalid");return{x:q,y:O}}),w=_t(p=>{if(p.is0()){if(n.allowInfinityPoint&&!e.is0(p.py))return;throw new Error("bad point: ZERO")}const{x:u,y}=p.toAffine();if(!e.isValid(u)||!e.isValid(y))throw new Error("bad point: x or y not FE");const S=e.sqr(y),b=c(u);if(!e.eql(S,b))throw new Error("bad point: equation left != right");if(!p.isTorsionFree())throw new Error("bad point: not in prime-order subgroup");return!0});class g{constructor(u,y,S){if(this.px=u,this.py=y,this.pz=S,u==null||!e.isValid(u))throw new Error("x required");if(y==null||!e.isValid(y))throw new Error("y required");if(S==null||!e.isValid(S))throw new Error("z required");Object.freeze(this)}static fromAffine(u){const{x:y,y:S}=u||{};if(!u||!e.isValid(y)||!e.isValid(S))throw new Error("invalid affine point");if(u instanceof g)throw new Error("projective point not allowed");const b=v=>e.eql(v,e.ZERO);return b(y)&&b(S)?g.ZERO:new g(y,S,e.ONE)}get x(){return this.toAffine().x}get y(){return this.toAffine().y}static normalizeZ(u){const y=e.invertBatch(u.map(S=>S.pz));return u.map((S,b)=>S.toAffine(y[b])).map(g.fromAffine)}static fromHex(u){const y=g.fromAffine(o(K("pointHex",u)));return y.assertValidity(),y}static fromPrivateKey(u){return g.BASE.multiply(i(u))}static msm(u,y){return Ne(g,r,u,y)}_setWindowSize(u){R.setWindowSize(this,u)}assertValidity(){w(this)}hasEvenY(){const{y:u}=this.toAffine();if(e.isOdd)return!e.isOdd(u);throw new Error("Field doesn't support isOdd")}equals(u){d(u);const{px:y,py:S,pz:b}=this,{px:v,py:q,pz:O}=u,H=e.eql(e.mul(y,O),e.mul(v,b)),I=e.eql(e.mul(S,O),e.mul(q,b));return H&&I}negate(){return new g(this.px,e.neg(this.py),this.pz)}double(){const{a:u,b:y}=n,S=e.mul(y,xe),{px:b,py:v,pz:q}=this;let O=e.ZERO,H=e.ZERO,I=e.ZERO,L=e.mul(b,b),G=e.mul(v,v),z=e.mul(q,q),$=e.mul(b,v);return $=e.add($,$),I=e.mul(b,q),I=e.add(I,I),O=e.mul(u,I),H=e.mul(S,z),H=e.add(O,H),O=e.sub(G,H),H=e.add(G,H),H=e.mul(O,H),O=e.mul($,O),I=e.mul(S,I),z=e.mul(u,z),$=e.sub(L,z),$=e.mul(u,$),$=e.add($,I),I=e.add(L,L),L=e.add(I,L),L=e.add(L,z),L=e.mul(L,$),H=e.add(H,L),z=e.mul(v,q),z=e.add(z,z),L=e.mul(z,$),O=e.sub(O,L),I=e.mul(z,G),I=e.add(I,I),I=e.add(I,I),new g(O,H,I)}add(u){d(u);const{px:y,py:S,pz:b}=this,{px:v,py:q,pz:O}=u;let H=e.ZERO,I=e.ZERO,L=e.ZERO;const G=n.a,z=e.mul(n.b,xe);let $=e.mul(y,v),M=e.mul(S,q),m=e.mul(b,O),B=e.add(y,S),h=e.add(v,q);B=e.mul(B,h),h=e.add($,M),B=e.sub(B,h),h=e.add(y,b);let l=e.add(v,O);return h=e.mul(h,l),l=e.add($,m),h=e.sub(h,l),l=e.add(S,b),H=e.add(q,O),l=e.mul(l,H),H=e.add(M,m),l=e.sub(l,H),L=e.mul(G,h),H=e.mul(z,m),L=e.add(H,L),H=e.sub(M,L),L=e.add(M,L),I=e.mul(H,L),M=e.add($,$),M=e.add(M,$),m=e.mul(G,m),h=e.mul(z,h),M=e.add(M,m),m=e.sub($,m),m=e.mul(G,m),h=e.add(h,m),$=e.mul(M,h),I=e.add(I,$),$=e.mul(l,h),H=e.mul(B,H),H=e.sub(H,$),$=e.mul(B,M),L=e.mul(l,L),L=e.add(L,$),new g(H,I,L)}subtract(u){return this.add(u.negate())}is0(){return this.equals(g.ZERO)}wNAF(u){return R.wNAFCached(this,u,g.normalizeZ)}multiplyUnsafe(u){rt("scalar",u,at,n.n);const y=g.ZERO;if(u===at)return y;if(u===P)return this;const{endo:S}=n;if(!S)return R.unsafeLadder(this,u);let{k1neg:b,k1:v,k2neg:q,k2:O}=S.splitScalar(u),H=y,I=y,L=this;for(;v>at||O>at;)v&P&&(H=H.add(L)),O&P&&(I=I.add(L)),L=L.double(),v>>=P,O>>=P;return b&&(H=H.negate()),q&&(I=I.negate()),I=new g(e.mul(I.px,S.beta),I.py,I.pz),H.add(I)}multiply(u){const{endo:y,n:S}=n;rt("scalar",u,P,S);let b,v;if(y){const{k1neg:q,k1:O,k2neg:H,k2:I}=y.splitScalar(u);let{p:L,f:G}=this.wNAF(O),{p:z,f:$}=this.wNAF(I);L=R.constTimeNegate(q,L),z=R.constTimeNegate(H,z),z=new g(e.mul(z.px,y.beta),z.py,z.pz),b=L.add(z),v=G.add($)}else{const{p:q,f:O}=this.wNAF(u);b=q,v=O}return g.normalizeZ([b,v])[0]}multiplyAndAddUnsafe(u,y,S){const b=g.BASE,v=(O,H)=>H===at||H===P||!O.equals(b)?O.multiplyUnsafe(H):O.multiply(H),q=v(this,y).add(v(u,S));return q.is0()?void 0:q}toAffine(u){return a(this,u)}isTorsionFree(){const{h:u,isTorsionFree:y}=n;if(u===P)return!0;if(y)return y(g,this);throw new Error("isTorsionFree() has not been declared for the elliptic curve")}clearCofactor(){const{h:u,clearCofactor:y}=n;return u===P?this:y?y(g,this):this.multiplyUnsafe(n.h)}toRawBytes(u=!0){return lt("isCompressed",u),this.assertValidity(),s(g,this,u)}toHex(u=!0){return lt("isCompressed",u),yt(this.toRawBytes(u))}}g.BASE=new g(n.Gx,n.Gy,e.ONE),g.ZERO=new g(e.ZERO,e.ONE,e.ZERO);const A=n.nBitLength,R=Oe(g,n.endo?Math.ceil(A/2):A);return{CURVE:n,ProjectivePoint:g,normPrivateKeyToScalar:i,weierstrassEquation:c,isWithinCurveOrder:f}}function ar(t){const n=Jt(t);return vt(n,{hash:"hash",hmac:"function",randomBytes:"function"},{bits2int:"function",bits2int_modN:"function",lowS:"boolean"}),Object.freeze({lowS:!0,...n})}function lr(t){const n=ar(t),{Fp:e,n:r}=n,s=e.BYTES+1,o=2*e.BYTES+1;function c(m){return F(m,r)}function f(m){return Mt(m,r)}const{ProjectivePoint:i,normPrivateKeyToScalar:d,weierstrassEquation:a,isWithinCurveOrder:w}=fr({...n,toBytes(m,B,h){const l=B.toAffine(),x=e.toBytes(l.x),E=pt;return lt("isCompressed",h),h?E(Uint8Array.from([B.hasEvenY()?2:3]),x):E(Uint8Array.from([4]),x,e.toBytes(l.y))},fromBytes(m){const B=m.length,h=m[0],l=m.subarray(1);if(B===s&&(h===2||h===3)){const x=bt(l);if(!Ut(x,P,e.ORDER))throw new Error("Point is not on curve");const E=a(x);let _;try{_=e.sqrt(E)}catch(C){const Z=C instanceof Error?": "+C.message:"";throw new Error("Point is not on curve"+Z)}const N=(_&P)===P;return(h&1)===1!==N&&(_=e.neg(_)),{x,y:_}}else if(B===o&&h===4){const x=e.fromBytes(l.subarray(0,e.BYTES)),E=e.fromBytes(l.subarray(e.BYTES,2*e.BYTES));return{x,y:E}}else throw new Error(`Point of length ${B} was invalid. Expected ${s} compressed bytes or ${o} uncompressed bytes`)}}),g=m=>yt(At(m,n.nByteLength));function A(m){const B=r>>P;return m>B}function R(m){return A(m)?c(-m):m}const p=(m,B,h)=>bt(m.slice(B,h));class u{constructor(B,h,l){this.r=B,this.s=h,this.recovery=l,this.assertValidity()}static fromCompact(B){const h=n.nByteLength;return B=K("compactSignature",B,h*2),new u(p(B,0,h),p(B,h,2*h))}static fromDER(B){const{r:h,s:l}=ft.toSig(K("DER",B));return new u(h,l)}assertValidity(){rt("r",this.r,P,r),rt("s",this.s,P,r)}addRecoveryBit(B){return new u(this.r,this.s,B)}recoverPublicKey(B){const{r:h,s:l,recovery:x}=this,E=O(K("msgHash",B));if(x==null||![0,1,2,3].includes(x))throw new Error("recovery id invalid");const _=x===2||x===3?h+n.n:h;if(_>=e.ORDER)throw new Error("recovery id 2 or 3 invalid");const N=x&1?"03":"02",U=i.fromHex(N+g(_)),C=f(_),Z=c(-E*C),k=c(l*C),V=i.BASE.multiplyAndAddUnsafe(U,Z,k);if(!V)throw new Error("point at infinify");return V.assertValidity(),V}hasHighS(){return A(this.s)}normalizeS(){return this.hasHighS()?new u(this.r,c(-this.s),this.recovery):this}toDERRawBytes(){return St(this.toDERHex())}toDERHex(){return ft.hexFromSig({r:this.r,s:this.s})}toCompactRawBytes(){return St(this.toCompactHex())}toCompactHex(){return g(this.r)+g(this.s)}}const y={isValidPrivateKey(m){try{return d(m),!0}catch{return!1}},normPrivateKeyToScalar:d,randomPrivateKey:()=>{const m=_e(n.n);return Fn(n.randomBytes(m),n.n)},precompute(m=8,B=i.BASE){return B._setWindowSize(m),B.multiply(BigInt(3)),B}};function S(m,B=!0){return i.fromPrivateKey(m).toRawBytes(B)}function b(m){const B=xt(m),h=typeof m=="string",l=(B||h)&&m.length;return B?l===s||l===o:h?l===2*s||l===2*o:m instanceof i}function v(m,B,h=!0){if(b(m))throw new Error("first arg must be private key");if(!b(B))throw new Error("second arg must be public key");return i.fromHex(B).multiply(d(m)).toRawBytes(h)}const q=n.bits2int||function(m){const B=bt(m),h=m.length*8-n.nBitLength;return h>0?B>>BigInt(h):B},O=n.bits2int_modN||function(m){return c(q(m))},H=Qt(n.nBitLength);function I(m){return rt(`num < 2^${n.nBitLength}`,m,at,H),At(m,n.nByteLength)}function L(m,B,h=G){if(["recovered","canonical"].some(W=>W in h))throw new Error("sign() legacy options not supported");const{hash:l,randomBytes:x}=n;let{lowS:E,prehash:_,extraEntropy:N}=h;E==null&&(E=!0),m=K("msgHash",m),be(h),_&&(m=K("prehashed msgHash",l(m)));const U=O(m),C=d(B),Z=[I(C),I(U)];if(N!=null&&N!==!1){const W=N===!0?x(e.BYTES):N;Z.push(K("extraEntropy",W))}const k=pt(...Z),V=U;function X(W){const J=q(W);if(!w(J))return;const tt=f(J),et=i.BASE.multiply(J).toAffine(),D=c(et.x);if(D===at)return;const ot=c(tt*c(V+D*C));if(ot===at)return;let It=(et.x===D?0:2)|Number(et.y&P),Ht=ot;return E&&A(ot)&&(Ht=R(ot),It^=1),new u(D,Ht,It)}return{seed:k,k2sig:X}}const G={lowS:n.lowS,prehash:!1},z={lowS:n.lowS,prehash:!1};function $(m,B,h=G){const{seed:l,k2sig:x}=L(m,B,h),E=n;return Ie(E.hash.outputLen,E.nByteLength,E.hmac)(l,x)}i.BASE._setWindowSize(8);function M(m,B,h,l=z){var et;const x=m;if(B=K("msgHash",B),h=K("publicKey",h),"strict"in l)throw new Error("options.strict was renamed to lowS");be(l);const{lowS:E,prehash:_}=l;let N,U;try{if(typeof x=="string"||xt(x))try{N=u.fromDER(x)}catch(D){if(!(D instanceof ft.Err))throw D;N=u.fromCompact(x)}else if(typeof x=="object"&&typeof x.r=="bigint"&&typeof x.s=="bigint"){const{r:D,s:ot}=x;N=new u(D,ot)}else throw new Error("PARSE");U=i.fromHex(h)}catch(D){if(D.message==="PARSE")throw new Error("signature must be Signature instance, Uint8Array or hex string");return!1}if(E&&N.hasHighS())return!1;_&&(B=n.hash(B));const{r:C,s:Z}=N,k=O(B),V=f(Z),X=c(k*V),W=c(C*V),J=(et=i.BASE.multiplyAndAddUnsafe(U,X,W))==null?void 0:et.toAffine();return J?c(J.x)===C:!1}return{CURVE:n,getPublicKey:S,getSharedSecret:v,sign:$,verify:M,ProjectivePoint:i,Signature:u,utils:y}}/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */function ur(t){return{hash:t,hmac:(n,...e)=>Te(t,n,De(...e)),randomBytes:Ee}}function dr(t,n){const e=r=>lr({...t,...ur(r)});return Object.freeze({...e(n),create:e})}/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */const Re=BigInt("0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc2f"),ye=BigInt("0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141"),hr=BigInt(1),Dt=BigInt(2),pe=(t,n)=>(t+n/Dt)/n;function gr(t){const n=Re,e=BigInt(3),r=BigInt(6),s=BigInt(11),o=BigInt(22),c=BigInt(23),f=BigInt(44),i=BigInt(88),d=t*t*t%n,a=d*d*t%n,w=j(a,e,n)*a%n,g=j(w,e,n)*a%n,A=j(g,Dt,n)*d%n,R=j(A,s,n)*A%n,p=j(R,o,n)*R%n,u=j(p,f,n)*p%n,y=j(u,i,n)*u%n,S=j(y,f,n)*p%n,b=j(S,e,n)*a%n,v=j(b,c,n)*R%n,q=j(v,r,n)*d%n,O=j(q,Dt,n);if(!Kt.eql(Kt.sqr(O),t))throw new Error("Cannot find square root");return O}const Kt=Zt(Re,void 0,void 0,{sqrt:gr}),wr=dr({a:BigInt(0),b:BigInt(7),Fp:Kt,n:ye,Gx:BigInt("55066263022277343669578718895168534326250603453777594175500187360389116729240"),Gy:BigInt("32670510020758816978083085130507043184471273380659243275938904335757337482424"),h:BigInt(1),lowS:!0,endo:{beta:BigInt("0x7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee"),splitScalar:t=>{const n=ye,e=BigInt("0x3086d221a7d46bcde86c90e49284eb15"),r=-hr*BigInt("0xe4437ed6010e88286f547fa90abfe4c3"),s=BigInt("0x114ca50f7a8e2f3f657c1108d9d44cfd8"),o=e,c=BigInt("0x100000000000000000000000000000000"),f=pe(o*t,n),i=pe(-r*t,n);let d=F(t-f*e-i*s,n),a=F(-f*r-i*o,n);const w=d>c,g=a>c;if(w&&(d=n-d),g&&(a=n-a),d>c||a>c)throw new Error("splitScalar: Endomorphism failed, k="+t);return{k1neg:w,k1:d,k2neg:g,k2:a}}}},or);BigInt(0);wr.ProjectivePoint;export{or as a,br as e,wr as s};
